Generated by [trace_location](https://github.com/yhirano55/trace_location) at 2019-06-08 01:09:55 +0900

<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:49</summary>

##### ActiveRecord::ConnectionHandling.establish_connection

```ruby
def establish_connection(config = nil)
  raise "Anonymous class is not allowed." unless name

  config ||= DEFAULT_ENV.call.to_sym
  spec_name = self == Base ? "primary" : name
  self.connection_specification_name = spec_name

  resolver = ConnectionAdapters::ConnectionSpecification::Resolver.new(Base.configurations)
  spec = resolver.resolve(config).symbolize_keys
  spec[:name] = spec_name

  connection_handler.establish_connection(spec)
end
# called from (irb):4
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:59</summary>

##### ActiveRecord::Base.configurations

```ruby
def self.configurations
  @@configurations
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:56
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:121</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#initialize

```ruby
def initialize(configurations)
  @configurations = configurations
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:56
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:141</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve

```ruby
def resolve(config)
  if config
    resolve_connection config
  elsif env = ActiveRecord::ConnectionHandling::RAILS_ENV.call
    resolve_symbol_connection env.to_sym
  else
    raise AdapterNotSpecified
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:238</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve_connection

```ruby
def resolve_connection(spec)
  case spec
  when Symbol
    resolve_symbol_connection spec
  when String
    resolve_url_connection spec
  when Hash
    resolve_hash_connection spec
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:143
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:268</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve_hash_connection

```ruby
def resolve_hash_connection(spec)
  if spec["url"] && spec["url"] !~ /^jdbc:/
    connection_hash = resolve_url_connection(spec.delete("url"))
    spec.merge!(connection_hash)
  end
  spec
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:245
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/keys.rb:56</summary>

##### Hash#symbolize_keys

```ruby
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:130</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:954</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#establish_connection

```ruby
def establish_connection(config)
  resolver = ConnectionSpecification::Resolver.new(Base.configurations)
  spec = resolver.spec(config)

  remove_connection(spec.name)

  message_bus = ActiveSupport::Notifications.instrumenter
  payload = {
    connection_id: object_id
  }
  if spec
    payload[:spec_name] = spec.name
    payload[:config] = spec.config
  end

  message_bus.instrument("!connection.active_record", payload) do
    owner_to_pool[spec.name] = ConnectionAdapters::ConnectionPool.new(spec)
  end

  owner_to_pool[spec.name]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:59</summary>

##### ActiveRecord::Base.configurations

```ruby
def self.configurations
  @@configurations
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:955
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:121</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#initialize

```ruby
def initialize(configurations)
  @configurations = configurations
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:955
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:181</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#spec

```ruby
def spec(config)
  spec = resolve(config).symbolize_keys

  raise(AdapterNotSpecified, "database configuration does not specify adapter") unless spec.key?(:adapter)

  # Require the adapter itself and give useful feedback about
  #   1. Missing adapter gems and
  #   2. Adapter gems' missing dependencies.
  path_to_adapter = "active_record/connection_adapters/#{spec[:adapter]}_adapter"
  begin
    require path_to_adapter
  rescue LoadError => e
    # We couldn't require the adapter itself. Raise an exception that
    # points out config typos and missing gems.
    if e.path == path_to_adapter
      # We can assume that a non-builtin adapter was specified, so it's
      # either misspelled or missing from Gemfile.
      raise LoadError, "Could not load the '#{spec[:adapter]}' Active Record adapter. Ensure that the adapter is spelled correctly in config/database.yml and that you've added the necessary adapter gem to your Gemfile.", e.backtrace

    # Bubbled up from the adapter require. Prefix the exception message
    # with some guidance about how to address it and reraise.
    else
      raise LoadError, "Error loading the '#{spec[:adapter]}' Active Record adapter. Missing a gem it depends on? #{e.message}", e.backtrace
    end
  end

  adapter_method = "#{spec[:adapter]}_connection"

  unless ActiveRecord::Base.respond_to?(adapter_method)
    raise AdapterNotFound, "database configuration specifies nonexistent #{spec.config[:adapter]} adapter"
  end

  ConnectionSpecification.new(spec.delete(:name) || "primary", spec, adapter_method)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:956
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:141</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve

```ruby
def resolve(config)
  if config
    resolve_connection config
  elsif env = ActiveRecord::ConnectionHandling::RAILS_ENV.call
    resolve_symbol_connection env.to_sym
  else
    raise AdapterNotSpecified
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:182
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:238</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve_connection

```ruby
def resolve_connection(spec)
  case spec
  when Symbol
    resolve_symbol_connection spec
  when String
    resolve_url_connection spec
  when Hash
    resolve_hash_connection spec
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:143
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:268</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver#resolve_hash_connection

```ruby
def resolve_hash_connection(spec)
  if spec["url"] && spec["url"] !~ /^jdbc:/
    connection_hash = resolve_url_connection(spec.delete("url"))
    spec.merge!(connection_hash)
  end
  spec
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:245
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/keys.rb:56</summary>

##### Hash#symbolize_keys

```ruby
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:182
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:289</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:191
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:251</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && Dependencies.constant_watch_stack.watching?
    descs = Dependencies.constant_watch_stack.watching.flatten.uniq

    Dependencies.new_constants_in(*descs) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:291
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:328</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:329
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:111</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:10</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionSpecification#initialize

```ruby
def initialize(name, config, adapter_method)
  @name, @config, @adapter_method = name, config, adapter_method
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/connection_specification.rb:213
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1028</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#remove_connection

```ruby
def remove_connection(spec_name)
  if pool = owner_to_pool.delete(spec_name)
    pool.automatic_reconnect = false
    pool.disconnect!
    pool.spec.config
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:958
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1029
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:53</summary>

##### Concurrent::Collection::MriMapBackend#delete

```ruby
def delete(key)
  @write_lock.synchronize { super }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1029
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:79</summary>

##### Concurrent::Collection::MriMapBackend#delete

```ruby
def delete(key)
  @write_lock.synchronize { super }
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:454</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#disconnect!

```ruby
def disconnect!
  disconnect(false)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1031
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:432</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#disconnect

```ruby
def disconnect(raise_on_acquisition_timeout = true)
  with_exclusively_acquired_all_connections(raise_on_acquisition_timeout) do
    synchronize do
      @connections.each do |conn|
        if conn.in_use?
          conn.steal!
          checkin conn
        end
        conn.disconnect!
      end
      @connections = []
      @available.clear
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:455
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:675</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#with_exclusively_acquired_all_connections

```ruby
def with_exclusively_acquired_all_connections(raise_on_acquisition_timeout = true)
  with_new_connections_blocked do
    attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout)
    yield
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:433
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:748</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#with_new_connections_blocked

```ruby
def with_new_connections_blocked
  synchronize do
    @threads_blocking_new_connections += 1
  end

  yield
ensure
  num_new_conns_required = 0

  synchronize do
    @threads_blocking_new_connections -= 1

    if @threads_blocking_new_connections.zero?
      @available.clear

      num_new_conns_required = num_waiting_in_queue

      @connections.each do |conn|
        next if conn.in_use?

        @available.add conn
        num_new_conns_required -= 1
      end
    end
  end

  bulk_make_new_connections(num_new_conns_required) if num_new_conns_required > 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:676
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:749
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:682</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#attempt_to_checkout_all_existing_connections

```ruby
def attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout = true)
  collected_conns = synchronize do
    # account for our own connections
    @connections.select { |conn| conn.owner == Thread.current }
  end

  newly_checked_out = []
  timeout_time      = Time.now + (@checkout_timeout * 2)

  @available.with_a_bias_for(Thread.current) do
    loop do
      synchronize do
        return if collected_conns.size == @connections.size && @now_connecting == 0
        remaining_timeout = timeout_time - Time.now
        remaining_timeout = 0 if remaining_timeout < 0
        conn = checkout_for_exclusive_access(remaining_timeout)
        collected_conns   << conn
        newly_checked_out << conn
      end
    end
  end
rescue ExclusiveConnectionTimeoutError
  # <tt>raise_on_acquisition_timeout == false</tt> means we are directed to ignore any
  # timeouts and are expected to just give up: we've obtained as many connections
  # as possible, note that in a case like that we don't return any of the
  # +newly_checked_out+ connections.

  if raise_on_acquisition_timeout
    release_newly_checked_out = true
    raise
  end
rescue Exception # if something else went wrong
  # this can't be a "naked" rescue, because we have should return conns
  # even for non-StandardErrors
  release_newly_checked_out = true
  raise
ensure
  if release_newly_checked_out && newly_checked_out
    # releasing only those conns that were checked out in this method, conns
    # checked outside this method (before it was called) are not for us to release
    newly_checked_out.each { |conn| checkin(conn) }
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:677
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:683
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/time/calculations.rb:261</summary>

##### Time#plus_with_duration

```ruby
def plus_with_duration(other) #:nodoc:
  if ActiveSupport::Duration === other
    other.since(self)
  else
    plus_without_duration(other)
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:689
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/duration.rb:144</summary>

##### ActiveSupport::Duration.===

```ruby
def ===(other) #:nodoc:
  other.is_a?(Duration)
rescue ::NoMethodError
  false
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/time/calculations.rb:262
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:251</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue#with_a_bias_for

```ruby
def with_a_bias_for(thread)
  previous_cond = nil
  new_cond      = nil
  synchronize do
    previous_cond = @cond
    @cond = new_cond = BiasedConditionVariable.new(@lock, @cond, thread)
  end
  yield
ensure
  synchronize do
    @cond = previous_cond if previous_cond
    new_cond.broadcast_on_biased if new_cond # wake up any remaining sleepers
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:691
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:154</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#synchronize

```ruby
def synchronize(&block)
  @lock.synchronize(&block)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:254
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:155
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:215</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable#initialize

```ruby
def initialize(lock, other_cond, preferred_thread)
  @real_cond = lock.new_cond
  @other_cond = other_cond
  @preferred_thread = preferred_thread
  @num_waiting_on_real_cond = 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:256
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:241</summary>

##### MonitorMixin#new_cond

```ruby
def new_cond
  return ConditionVariable.new(self)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:216
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:156</summary>

##### MonitorMixin::ConditionVariable#initialize

```ruby
def initialize(monitor)
  @monitor = monitor
  @cond = Thread::ConditionVariable.new
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:242
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:693
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:154</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#synchronize

```ruby
def synchronize(&block)
  @lock.synchronize(&block)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:260
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:155
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:227</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable#broadcast_on_biased

```ruby
def broadcast_on_biased
  @num_waiting_on_real_cond = 0
  @real_cond.broadcast
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:262
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:149</summary>

##### MonitorMixin::ConditionVariable#broadcast

```ruby
def broadcast
  @monitor.__send__(:mon_check_owner)
  @cond.broadcast
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:229
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:150
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:434
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:124</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#clear

```ruby
def clear
  synchronize do
    @queue.clear
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:443
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:154</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#synchronize

```ruby
def synchronize(&block)
  @lock.synchronize(&block)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:125
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:155
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:757
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:124</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#clear

```ruby
def clear
  synchronize do
    @queue.clear
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:761
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:154</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#synchronize

```ruby
def synchronize(&block)
  @lock.synchronize(&block)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:125
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:155
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:627</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#num_waiting_in_queue

```ruby
def num_waiting_in_queue # :nodoc:
  @available.num_waiting
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:763
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:102</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#num_waiting

```ruby
def num_waiting
  synchronize do
    @num_waiting
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:628
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:154</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#synchronize

```ruby
def synchronize(&block)
  @lock.synchronize(&block)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:103
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:155
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:960
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:19</summary>

##### ActiveSupport::Notifications::Instrumenter#instrument

```ruby
def instrument(name, payload = {})
  # some of the listeners might have state
  listeners_state = start name, payload
  begin
    yield payload
  rescue Exception => e
    payload[:exception] = [e.class.name, e.message]
    payload[:exception_object] = e
    raise e
  ensure
    finish_with_state listeners_state, name, payload
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:969
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:970
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:321</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#initialize

```ruby
def initialize(spec)
  super()

  @spec = spec

  @checkout_timeout = (spec.config[:checkout_timeout] && spec.config[:checkout_timeout].to_f) || 5
  if @idle_timeout = spec.config.fetch(:idle_timeout, 300)
    @idle_timeout = @idle_timeout.to_f
    @idle_timeout = nil if @idle_timeout <= 0
  end

  # default max pool size to 5
  @size = (spec.config[:pool] && spec.config[:pool].to_i) || 5

  # This variable tracks the cache of threads mapped to reserved connections, with the
  # sole purpose of speeding up the +connection+ method. It is not the authoritative
  # registry of which thread owns which connection. Connection ownership is tracked by
  # the +connection.owner+ attr on each +connection+ instance.
  # The invariant works like this: if there is mapping of <tt>thread => conn</tt>,
  # then that +thread+ does indeed own that +conn+. However, an absence of a such
  # mapping does not mean that the +thread+ doesn't own the said connection. In
  # that case +conn.owner+ attr should be consulted.
  # Access and modification of <tt>@thread_cached_conns</tt> does not require
  # synchronization.
  @thread_cached_conns = Concurrent::Map.new(initial_capacity: @size)

  @connections         = []
  @automatic_reconnect = true

  # Connection pool allows for concurrent (outside the main +synchronize+ section)
  # establishment of new connections. This variable tracks the number of threads
  # currently in the process of independently establishing connections to the DB.
  @now_connecting = 0

  @threads_blocking_new_connections = 0

  @available = ConnectionLeasingQueue.new self

  @lock_thread = false

  # +reaping_frequency+ is configurable mostly for historical reasons, but it could
  # also be useful if someone wants a very low +idle_timeout+.
  reaping_frequency = spec.config.fetch(:reaping_frequency, 60)
  @reaper = Reaper.new(self, reaping_frequency && reaping_frequency.to_f)
  @reaper.run
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:970
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:29</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#initialize

```ruby
def initialize(spec)
  super()

  @spec = spec

  @checkout_timeout = (spec.config[:checkout_timeout] && spec.config[:checkout_timeout].to_f) || 5
  if @idle_timeout = spec.config.fetch(:idle_timeout, 300)
    @idle_timeout = @idle_timeout.to_f
    @idle_timeout = nil if @idle_timeout <= 0
  end

  # default max pool size to 5
  @size = (spec.config[:pool] && spec.config[:pool].to_i) || 5

  # This variable tracks the cache of threads mapped to reserved connections, with the
  # sole purpose of speeding up the +connection+ method. It is not the authoritative
  # registry of which thread owns which connection. Connection ownership is tracked by
  # the +connection.owner+ attr on each +connection+ instance.
  # The invariant works like this: if there is mapping of <tt>thread => conn</tt>,
  # then that +thread+ does indeed own that +conn+. However, an absence of a such
  # mapping does not mean that the +thread+ doesn't own the said connection. In
  # that case +conn.owner+ attr should be consulted.
  # Access and modification of <tt>@thread_cached_conns</tt> does not require
  # synchronization.
  @thread_cached_conns = Concurrent::Map.new(initial_capacity: @size)

  @connections         = []
  @automatic_reconnect = true

  # Connection pool allows for concurrent (outside the main +synchronize+ section)
  # establishment of new connections. This variable tracks the number of threads
  # currently in the process of independently establishing connections to the DB.
  @now_connecting = 0

  @threads_blocking_new_connections = 0

  @available = ConnectionLeasingQueue.new self

  @lock_thread = false

  # +reaping_frequency+ is configurable mostly for historical reasons, but it could
  # also be useful if someone wants a very low +idle_timeout+.
  reaping_frequency = spec.config.fetch(:reaping_frequency, 60)
  @reaper = Reaper.new(self, reaping_frequency && reaping_frequency.to_f)
  @reaper.run
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:322
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:250</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#initialize

```ruby
def initialize(spec)
  super()

  @spec = spec

  @checkout_timeout = (spec.config[:checkout_timeout] && spec.config[:checkout_timeout].to_f) || 5
  if @idle_timeout = spec.config.fetch(:idle_timeout, 300)
    @idle_timeout = @idle_timeout.to_f
    @idle_timeout = nil if @idle_timeout <= 0
  end

  # default max pool size to 5
  @size = (spec.config[:pool] && spec.config[:pool].to_i) || 5

  # This variable tracks the cache of threads mapped to reserved connections, with the
  # sole purpose of speeding up the +connection+ method. It is not the authoritative
  # registry of which thread owns which connection. Connection ownership is tracked by
  # the +connection.owner+ attr on each +connection+ instance.
  # The invariant works like this: if there is mapping of <tt>thread => conn</tt>,
  # then that +thread+ does indeed own that +conn+. However, an absence of a such
  # mapping does not mean that the +thread+ doesn't own the said connection. In
  # that case +conn.owner+ attr should be consulted.
  # Access and modification of <tt>@thread_cached_conns</tt> does not require
  # synchronization.
  @thread_cached_conns = Concurrent::Map.new(initial_capacity: @size)

  @connections         = []
  @automatic_reconnect = true

  # Connection pool allows for concurrent (outside the main +synchronize+ section)
  # establishment of new connections. This variable tracks the number of threads
  # currently in the process of independently establishing connections to the DB.
  @now_connecting = 0

  @threads_blocking_new_connections = 0

  @available = ConnectionLeasingQueue.new self

  @lock_thread = false

  # +reaping_frequency+ is configurable mostly for historical reasons, but it could
  # also be useful if someone wants a very low +idle_timeout+.
  reaping_frequency = spec.config.fetch(:reaping_frequency, 60)
  @reaper = Reaper.new(self, reaping_frequency && reaping_frequency.to_f)
  @reaper.run
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:30
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:257</summary>

##### MonitorMixin#mon_initialize

```ruby
def mon_initialize
  if defined?(@mon_mutex) && @mon_mutex_owner_object_id == object_id
    raise ThreadError, "already initialized"
  end
  @mon_mutex = Thread::Mutex.new
  @mon_mutex_owner_object_id = object_id
  @mon_owner = nil
  @mon_count = 0
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:118</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:12</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:125
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:15</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:118</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:345
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:328</summary>

##### Concurrent::Map#validate_options_hash!

```ruby
def validate_options_hash!(options)
  if (initial_capacity = options[:initial_capacity]) && (!initial_capacity.kind_of?(Integer) || initial_capacity < 0)
    raise ArgumentError, ":initial_capacity must be a positive Integer"
  end
  if (load_factor = options[:load_factor]) && (!load_factor.kind_of?(Numeric) || load_factor <= 0 || load_factor > 1)
    raise ArgumentError, ":load_factor must be a number between 0 and 1"
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:120
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:12</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:125
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:15</summary>

##### Concurrent::Map#initialize

```ruby
def initialize(options = nil, &block)
  if options.kind_of?(::Hash)
    validate_options_hash!(options)
  else
    options = nil
  end

  super(options)
  @default_proc = block
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:86</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Queue#initialize

```ruby
def initialize(lock = Monitor.new)
  @lock = lock
  @cond = @lock.new_cond
  @num_waiting = 0
  @queue = []
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:357
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:241</summary>

##### MonitorMixin#new_cond

```ruby
def new_cond
  return ConditionVariable.new(self)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:88
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:156</summary>

##### MonitorMixin::ConditionVariable#initialize

```ruby
def initialize(monitor)
  @monitor = monitor
  @cond = Thread::ConditionVariable.new
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:242
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:292</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper#initialize

```ruby
def initialize(pool, frequency)
  @pool      = pool
  @frequency = frequency
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:364
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:297</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper#run

```ruby
def run
  return unless frequency && frequency > 0
  Thread.new(frequency, pool) { |t, p|
    loop do
      sleep t
      p.reap
      p.flush
    end
  }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:365
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:17</summary>

##### Concurrent::Collection::MriMapBackend#[]=

```ruby
def []=(key, value)
  @write_lock.synchronize { super }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:970
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:23</summary>

##### Concurrent::Collection::MriMapBackend#[]=

```ruby
def []=(key, value)
  @write_lock.synchronize { super }
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/mri_map_backend.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:43</summary>

##### ActiveSupport::Notifications::Instrumenter#finish_with_state

```ruby
def finish_with_state(listeners_state, name, payload)
  @notifier.finish name, @id, payload, listeners_state
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:47</summary>

##### ActiveSupport::Notifications::Fanout#finish

```ruby
def finish(name, id, payload, listeners = listeners_for(name))
  listeners.each { |s| s.finish(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:973
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:973
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
