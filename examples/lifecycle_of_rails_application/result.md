Generated by [trace_location](https://github.com/yhirano55/trace_location) at 2019-06-08 01:23:17 +0900

<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails.rb:39</summary>

##### Rails.application

```ruby
def application
  @application ||= (app_class.instance if app_class)
end
# called from (irb):3
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:522</summary>

##### Rails::Engine#call

```ruby
def call(env)
  req = build_request env
  app.call req.env
end
# called from (irb):3
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/application.rb:607</summary>

##### Rails::Application#build_request

```ruby
def build_request(env)
  req = super
  env["ORIGINAL_FULLPATH"] = req.fullpath
  env["ORIGINAL_SCRIPT_NAME"] = req.script_name
  req
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:523
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:705</summary>

##### Rails::Application#build_request

```ruby
def build_request(env)
  req = super
  env["ORIGINAL_FULLPATH"] = req.fullpath
  env["ORIGINAL_SCRIPT_NAME"] = req.script_name
  req
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application.rb:608
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/application.rb:247</summary>

##### Rails::Application#env_config

```ruby
def env_config
  @app_env_config ||= begin
    super.merge(
      "action_dispatch.parameter_filter" => config.filter_parameters,
      "action_dispatch.redirect_filter" => config.filter_redirect,
      "action_dispatch.secret_token" => secrets.secret_token,
      "action_dispatch.secret_key_base" => secret_key_base,
      "action_dispatch.show_exceptions" => config.action_dispatch.show_exceptions,
      "action_dispatch.show_detailed_exceptions" => config.consider_all_requests_local,
      "action_dispatch.logger" => Rails.logger,
      "action_dispatch.backtrace_cleaner" => Rails.backtrace_cleaner,
      "action_dispatch.key_generator" => key_generator,
      "action_dispatch.http_auth_salt" => config.action_dispatch.http_auth_salt,
      "action_dispatch.signed_cookie_salt" => config.action_dispatch.signed_cookie_salt,
      "action_dispatch.encrypted_cookie_salt" => config.action_dispatch.encrypted_cookie_salt,
      "action_dispatch.encrypted_signed_cookie_salt" => config.action_dispatch.encrypted_signed_cookie_salt,
      "action_dispatch.authenticated_encrypted_cookie_salt" => config.action_dispatch.authenticated_encrypted_cookie_salt,
      "action_dispatch.use_authenticated_cookie_encryption" => config.action_dispatch.use_authenticated_cookie_encryption,
      "action_dispatch.encrypted_cookie_cipher" => config.action_dispatch.encrypted_cookie_cipher,
      "action_dispatch.signed_cookie_digest" => config.action_dispatch.signed_cookie_digest,
      "action_dispatch.cookies_serializer" => config.action_dispatch.cookies_serializer,
      "action_dispatch.cookies_digest" => config.action_dispatch.cookies_digest,
      "action_dispatch.cookies_rotations" => config.action_dispatch.cookies_rotations,
      "action_dispatch.content_security_policy" => config.content_security_policy,
      "action_dispatch.content_security_policy_report_only" => config.content_security_policy_report_only,
      "action_dispatch.content_security_policy_nonce_generator" => config.content_security_policy_nonce_generator
    )
  end
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:706
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:707
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:534</summary>

##### Rails::Engine#routes

```ruby
def routes
  @routes ||= ActionDispatch::Routing::RouteSet.new_with_config(config)
  @routes.append(&Proc.new) if block_given?
  @routes
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:708
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:142</summary>

##### ActionDispatch::Request#routes=

```ruby
def routes=(routes) # :nodoc:
  set_header("action_dispatch.routes".freeze, routes)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:708
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:143
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:709
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:150</summary>

##### ActionDispatch::Request#engine_script_name=

```ruby
def engine_script_name=(name) # :nodoc:
  set_header(routes.env_key, name.dup)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:709
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:138</summary>

##### ActionDispatch::Request#routes

```ruby
def routes # :nodoc:
  get_header("action_dispatch.routes".freeze)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:151
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:139
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:151
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:238</summary>

##### ActionDispatch::Request#fullpath

```ruby
def fullpath
  @fullpath ||= super
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application.rb:609
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:407</summary>

##### ActionDispatch::Request#fullpath

```ruby
def fullpath
  @fullpath ||= super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:239
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136</summary>

##### Rack::Request::Helpers#query_string

```ruby
def query_string;    get_header(QUERY_STRING).to_s                  end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:403</summary>

##### Rack::Request::Helpers#path

```ruby
def path
  script_name + path_info
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application.rb:610
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:505</summary>

##### Rails::Engine#app

```ruby
def app
  @app || @app_build_lock.synchronize {
    @app ||= begin
      stack = default_middleware_stack
      config.middleware = build_middleware.merge_into(stack)
      config.middleware.build(endpoint)
    end
  }
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:524
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/sendfile.rb:110</summary>

##### Rack::Sendfile#call

```ruby
def call(env)
  status, headers, body = @app.call(env)
  if body.respond_to?(:to_path)
    case type = variation(env)
    when 'X-Accel-Redirect'
      path = ::File.expand_path(body.to_path)
      if url = map_accel_path(env, path)
        headers[CONTENT_LENGTH] = '0'
        headers[type] = url
        obody = body
        body = Rack::BodyProxy.new([]) do
          obody.close if obody.respond_to?(:close)
        end
      else
        env[RACK_ERRORS].puts "X-Accel-Mapping header missing"
      end
    when 'X-Sendfile', 'X-Lighttpd-Send-File'
      path = ::File.expand_path(body.to_path)
      headers[CONTENT_LENGTH] = '0'
      headers[type] = path
      obody = body
      body = Rack::BodyProxy.new([]) do
        obody.close if obody.respond_to?(:close)
      end
    when '', nil
    else
      env[RACK_ERRORS].puts "Unknown x-sendfile variation: '#{type}'.\n"
    end
  end
  [status, headers, body]
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/engine.rb:524
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:116</summary>

##### ActionDispatch::Static#call

```ruby
def call(env)
  req = Rack::Request.new env

  if req.get? || req.head?
    path = req.path_info.chomp("/".freeze)
    if match = @file_handler.match?(path)
      req.path_info = match
      return @file_handler.serve(req)
    end
  end

  @app.call(req.env)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/sendfile.rb:111
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:16</summary>

##### Rack::Request#initialize

```ruby
def initialize(env)
  @params = nil
  super(env)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### Rack::Request#initialize

```ruby
def initialize(env)
  @params = nil
  super(env)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:162</summary>

##### Rack::Request::Helpers#get?

```ruby
def get?;     request_method == GET       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:119
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135</summary>

##### Rack::Request::Helpers#request_method

```ruby
def request_method;  get_header(REQUEST_METHOD)                     end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:162
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:120
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:30</summary>

##### ActionDispatch::FileHandler#match?

```ruby
def match?(path)
  path = ::Rack::Utils.unescape_path path
  return false unless ::Rack::Utils.valid_path? path
  path = ::Rack::Utils.clean_path_info path

  paths = [path, "#{path}#{ext}", "#{path}/#{@index}#{ext}"]

  if match = paths.detect { |p|
    path = File.join(@root, p.b)
    begin
      File.file?(path) && File.readable?(path)
    rescue SystemCallError
      false
    end

  }
    return ::Rack::Utils.escape_path(match).b
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:121
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:42</summary>

##### Rack::Utils.unescape_path

```ruby
def unescape_path(s)
  ::URI::DEFAULT_PARSER.unescape s
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:31
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/uri/rfc2396_parser.rb:331</summary>

##### URI::RFC2396_Parser#unescape

```ruby
def unescape(str, escaped = @regexp[:ESCAPED])
  enc = str.encoding
  enc = Encoding::UTF_8 if enc == Encoding::US_ASCII
  str.gsub(escaped) { [$&[1, 2]].pack('H2').force_encoding(enc) }
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:614</summary>

##### Rack::Utils.valid_path?

```ruby
def valid_path?(path)
  path.valid_encoding? && !path.include?(NULL_BYTE)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:596</summary>

##### Rack::Utils.clean_path_info

```ruby
def clean_path_info(path_info)
  parts = path_info.split PATH_SEPS

  clean = []

  parts.each do |part|
    next if part.empty? || part == '.'
    part == '..' ? clean.pop : clean << part
  end

  clean.unshift '/' if parts.empty? || parts.first.empty?

  ::File.join(*clean)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:33
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:78</summary>

##### ActionDispatch::FileHandler#ext

```ruby
def ext
  ::ActionController::Base.default_static_extension
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.default_static_extension

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:79
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#default_static_extension

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:78</summary>

##### ActionDispatch::FileHandler#ext

```ruby
def ext
  ::ActionController::Base.default_static_extension
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.default_static_extension

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:79
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#default_static_extension

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:11</summary>

##### ActionDispatch::Executor#call

```ruby
def call(env)
  state = @executor.run!
  begin
    response = @app.call(env)
    returned = response << ::Rack::BodyProxy.new(response.pop) { state.complete! }
  ensure
    state.complete! unless returned
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/static.rb:127
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/execution_wrapper.rb:65</summary>

##### ActiveSupport::ExecutionWrapper.run!

```ruby
def self.run!
  if active?
    Null
  else
    new.tap do |instance|
      success = nil
      begin
        instance.run!
        success = true
      ensure
        instance.complete! unless success
      end
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/execution_wrapper.rb:104</summary>

##### ActiveSupport::ExecutionWrapper.active?

```ruby
def self.active? # :nodoc:
  @active[Thread.current]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/execution_wrapper.rb:66
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:27</summary>

##### ActiveSupport::Cache::Strategy::LocalCache::Middleware#call

```ruby
def call(env)
  LocalCacheRegistry.set_cache_for(local_cache_key, LocalStore.new)
  response = @app.call(env)
  response[2] = ::Rack::BodyProxy.new(response[2]) do
    LocalCacheRegistry.set_cache_for(local_cache_key, nil)
  end
  cleanup_on_body_close = true
  response
rescue Rack::Utils::InvalidParameterError
  [400, {}, []]
ensure
  LocalCacheRegistry.set_cache_for(local_cache_key, nil) unless
    cleanup_on_body_close
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:39</summary>

##### ActiveSupport::Cache::Strategy::LocalCache::LocalStore#initialize

```ruby
def initialize
  super
  @data = {}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache.rb:183</summary>

##### ActiveSupport::Cache::Strategy::LocalCache::LocalStore#initialize

```ruby
def initialize
  super
  @data = {}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:40
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:32</summary>

##### ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry.set_cache_for

```ruby
def self.set_cache_for(l, v); instance.set_cache_for l, v; end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:28</summary>

##### ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry#set_cache_for

```ruby
def set_cache_for(local_cache_key, value)
  @registry[local_cache_key] = value
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:20</summary>

##### Rack::Runtime#call

```ruby
def call(env)
  start_time = Utils.clock_time
  status, headers, body = @app.call(env)
  request_time = Utils.clock_time - start_time

  unless headers.has_key?(@header_name)
    headers[@header_name] = FORMAT_STRING % request_time
  end

  [status, headers, body]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:81</summary>

##### Rack::Utils.clock_time

```ruby
def clock_time
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:24</summary>

##### ActionDispatch::RequestId#call

```ruby
def call(env)
  req = ActionDispatch::Request.new env
  req.request_id = make_request_id(req.x_request_id)
  @app.call(env).tap { |_status, headers, _body| headers[X_REQUEST_ID] = req.request_id }
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#x_request_id

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:31</summary>

##### ActionDispatch::RequestId#make_request_id

```ruby
def make_request_id(request_id)
  if request_id.presence
    request_id.gsub(/[^\w\-@]/, "".freeze).first(255)
  else
    internal_request_id
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:46</summary>

##### Object#presence

```ruby
def presence
  self if present?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:26</summary>

##### Object#present?

```ruby
def present?
  !blank?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:47
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:57</summary>

##### NilClass#blank?

```ruby
def blank?
  true
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:39</summary>

##### ActionDispatch::RequestId#internal_request_id

```ruby
def internal_request_id
  SecureRandom.uuid
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:35
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/securerandom.rb:233</summary>

##### Random::Formatter.uuid

```ruby
def uuid
  ary = random_bytes(16).unpack("NnnnnN")
  ary[2] = (ary[2] & 0x0fff) | 0x4000
  ary[3] = (ary[3] & 0x3fff) | 0x8000
  "%08x-%04x-%04x-%04x-%04x%08x" % ary
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:40
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/securerandom.rb:134</summary>

##### Random::Formatter.random_bytes

```ruby
def random_bytes(n=nil)
  n = n ? n.to_int : 16
  gen_random(n)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/securerandom.rb:234
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/securerandom.rb:103</summary>

##### SecureRandom.gen_random_urandom

```ruby
def gen_random_urandom(n)
  ret = Random.urandom(n)
  unless ret
    raise NotImplementedError, "No random device"
  end
  unless ret.length == n
    raise NotImplementedError, "Unexpected partial read from random device: only #{ret.length} for #{n} bytes"
  end
  ret
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/securerandom.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:298</summary>

##### ActionDispatch::Request#request_id=

```ruby
def request_id=(id) # :nodoc:
  set_header ACTION_DISPATCH_REQUEST_ID, id
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:299
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:78</summary>

##### ActionDispatch::RemoteIp#call

```ruby
def call(env)
  req = ActionDispatch::Request.new env
  req.remote_ip = GetIp.new(req, check_ip, proxies)
  @app.call(req.env)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:79
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:88</summary>

##### ActionDispatch::RemoteIp::GetIp#initialize

```ruby
def initialize(req, check_ip, proxies)
  @req      = req
  @check_ip = check_ip
  @proxies  = proxies
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:282</summary>

##### ActionDispatch::Request#remote_ip=

```ruby
def remote_ip=(remote_ip)
  set_header "action_dispatch.remote_ip".freeze, remote_ip
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:283
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:22</summary>

##### Rails::Rack::Logger#call

```ruby
def call(env)
  request = ActionDispatch::Request.new(env)

  if logger.respond_to?(:tagged)
    logger.tagged(compute_tags(request)) { call_app(request, env) }
  else
    call_app(request, env)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:81
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:75</summary>

##### Rails::Rack::Logger#logger

```ruby
def logger
  Rails.logger
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:75</summary>

##### Rails::Rack::Logger#logger

```ruby
def logger
  Rails.logger
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:57</summary>

##### Rails::Rack::Logger#compute_tags

```ruby
def compute_tags(request) # :doc:
  @taggers.collect do |tag|
    case tag
    when Proc
      tag.call(request)
    when Symbol
      request.send(tag)
    else
      tag
    end
  end
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:70</summary>

##### ActiveSupport::TaggedLogging#tagged

```ruby
def tagged(*tags)
  formatter.tagged(*tags) { yield self }
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:26</summary>

##### ActiveSupport::TaggedLogging::Formatter#tagged

```ruby
def tagged(*tags)
  new_tags = push_tags(*tags)
  yield self
ensure
  pop_tags(new_tags.size)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:33</summary>

##### ActiveSupport::TaggedLogging::Formatter#push_tags

```ruby
def push_tags(*tags)
  tags.flatten.reject(&:blank?).tap do |new_tags|
    current_tags.concat new_tags
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:34</summary>

##### Rails::Rack::Logger#call_app

```ruby
def call_app(request, env) # :doc:
  instrumenter = ActiveSupport::Notifications.instrumenter
  instrumenter.start "request.action_dispatch", request: request
  logger.info { started_request_message(request) }
  status, headers, body = @app.call(env)
  body = ::Rack::BodyProxy.new(body) { finish(request) }
  [status, headers, body]
rescue Exception
  finish(request)
  raise
ensure
  ActiveSupport::LogSubscriber.flush_all!
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:36
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:75</summary>

##### Rails::Rack::Logger#logger

```ruby
def logger
  Rails.logger
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:37
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:524</summary>

##### Logger#info

```ruby
def info(progname = nil, &block)
  add(INFO, nil, progname, &block)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:37
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:26</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:525
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:49</summary>

##### Rails::Rack::Logger#started_request_message

```ruby
def started_request_message(request) # :doc:
  'Started %s "%s" for %s at %s' % [
    request.request_method,
    request.filtered_path,
    request.remote_ip,
    Time.now.to_default_s ]
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:37
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:51
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:425</summary>

##### ActionDispatch::Request#check_method

```ruby
def check_method(name)
  HTTP_METHOD_LOOKUP[name] || raise(ActionController::UnknownHttpMethod, "#{name}, accepted HTTP methods are #{HTTP_METHODS[0...-1].join(', ')}, and #{HTTP_METHODS[-1]}")
  name
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:52</summary>

##### ActionDispatch::Http::FilterParameters#filtered_path

```ruby
def filtered_path
  @filtered_path ||= query_string.empty? ? path : "#{path}?#{filtered_query_string}"
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136</summary>

##### Rack::Request::Helpers#query_string

```ruby
def query_string;    get_header(QUERY_STRING).to_s                  end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:53
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:403</summary>

##### Rack::Request::Helpers#path

```ruby
def path
  script_name + path_info
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:53
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:278</summary>

##### ActionDispatch::Request#remote_ip

```ruby
def remote_ip
  @remote_ip ||= (get_header("action_dispatch.remote_ip") || ip).to_s
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:53
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:279
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:154</summary>

##### ActionDispatch::RemoteIp::GetIp#to_s

```ruby
def to_s
  @ip ||= calculate_ip
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:279
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:112</summary>

##### ActionDispatch::RemoteIp::GetIp#calculate_ip

```ruby
def calculate_ip
  # Set by the Rack web server, this is a single value.
  remote_addr = ips_from(@req.remote_addr).last

  # Could be a CSV list and/or repeated headers that were concatenated.
  client_ips    = ips_from(@req.client_ip).reverse
  forwarded_ips = ips_from(@req.x_forwarded_for).reverse

  # +Client-Ip+ and +X-Forwarded-For+ should not, generally, both be set.
  # If they are both set, it means that either:
  #
  # 1) This request passed through two proxies with incompatible IP header
  #    conventions.
  # 2) The client passed one of +Client-Ip+ or +X-Forwarded-For+
  #    (whichever the proxy servers weren't using) themselves.
  #
  # Either way, there is no way for us to determine which header is the
  # right one after the fact. Since we have no idea, if we are concerned
  # about IP spoofing we need to give up and explode. (If you're not
  # concerned about IP spoofing you can turn the +ip_spoofing_check+
  # option off.)
  should_check_ip = @check_ip && client_ips.last && forwarded_ips.last
  if should_check_ip && !forwarded_ips.include?(client_ips.last)
    # We don't know which came from the proxy, and which from the user
    raise IpSpoofAttackError, "IP spoofing attack?! " \
      "HTTP_CLIENT_IP=#{@req.client_ip.inspect} " \
      "HTTP_X_FORWARDED_FOR=#{@req.x_forwarded_for.inspect}"
  end

  # We assume these things about the IP headers:
  #
  #   - X-Forwarded-For will be a list of IPs, one per proxy, or blank
  #   - Client-Ip is propagated from the outermost proxy, or is blank
  #   - REMOTE_ADDR will be the IP that made the request to Rack
  ips = [forwarded_ips, client_ips, remote_addr].flatten.compact

  # If every single IP option is in the trusted list, just return REMOTE_ADDR
  filter_proxies(ips).first || remote_addr
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:155
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#remote_addr

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:114
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:114
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#client_ip

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#x_forwarded_for

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:176</summary>

##### ActionDispatch::RemoteIp::GetIp#filter_proxies

```ruby
def filter_proxies(ips) # :doc:
  ips.reject do |ip|
    @proxies.any? { |proxy| proxy === ip }
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:149
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::Logger::SimpleFormatter#call

```ruby
def call(severity, timestamp, progname, msg)
  "#{String === msg ? msg : msg.inspect}\n"
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:49</summary>

##### Rails::Rack::Logger#started_request_message

```ruby
def started_request_message(request) # :doc:
  'Started %s "%s" for %s at %s' % [
    request.request_method,
    request.filtered_path,
    request.remote_ip,
    Time.now.to_default_s ]
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:37
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:51
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:52</summary>

##### ActionDispatch::Http::FilterParameters#filtered_path

```ruby
def filtered_path
  @filtered_path ||= query_string.empty? ? path : "#{path}?#{filtered_query_string}"
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:278</summary>

##### ActionDispatch::Request#remote_ip

```ruby
def remote_ip
  @remote_ip ||= (get_header("action_dispatch.remote_ip") || ip).to_s
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:53
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:279
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:154</summary>

##### ActionDispatch::RemoteIp::GetIp#to_s

```ruby
def to_s
  @ip ||= calculate_ip
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:279
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:112</summary>

##### ActionDispatch::RemoteIp::GetIp#calculate_ip

```ruby
def calculate_ip
  # Set by the Rack web server, this is a single value.
  remote_addr = ips_from(@req.remote_addr).last

  # Could be a CSV list and/or repeated headers that were concatenated.
  client_ips    = ips_from(@req.client_ip).reverse
  forwarded_ips = ips_from(@req.x_forwarded_for).reverse

  # +Client-Ip+ and +X-Forwarded-For+ should not, generally, both be set.
  # If they are both set, it means that either:
  #
  # 1) This request passed through two proxies with incompatible IP header
  #    conventions.
  # 2) The client passed one of +Client-Ip+ or +X-Forwarded-For+
  #    (whichever the proxy servers weren't using) themselves.
  #
  # Either way, there is no way for us to determine which header is the
  # right one after the fact. Since we have no idea, if we are concerned
  # about IP spoofing we need to give up and explode. (If you're not
  # concerned about IP spoofing you can turn the +ip_spoofing_check+
  # option off.)
  should_check_ip = @check_ip && client_ips.last && forwarded_ips.last
  if should_check_ip && !forwarded_ips.include?(client_ips.last)
    # We don't know which came from the proxy, and which from the user
    raise IpSpoofAttackError, "IP spoofing attack?! " \
      "HTTP_CLIENT_IP=#{@req.client_ip.inspect} " \
      "HTTP_X_FORWARDED_FOR=#{@req.x_forwarded_for.inspect}"
  end

  # We assume these things about the IP headers:
  #
  #   - X-Forwarded-For will be a list of IPs, one per proxy, or blank
  #   - Client-Ip is propagated from the outermost proxy, or is blank
  #   - REMOTE_ADDR will be the IP that made the request to Rack
  ips = [forwarded_ips, client_ips, remote_addr].flatten.compact

  # If every single IP option is in the trusted list, just return REMOTE_ADDR
  filter_proxies(ips).first || remote_addr
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:155
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#remote_addr

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:114
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:114
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#client_ip

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:49</summary>

##### ActionDispatch::Request#x_forwarded_for

```ruby
def #{env.sub(/^HTTP_/n, '').downcase}  # def accept_charset
  get_header "#{env}".freeze            #   get_header "HTTP_ACCEPT_CHARSET".freeze
end                                     # end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:160</summary>

##### ActionDispatch::RemoteIp::GetIp#ips_from

```ruby
def ips_from(header) # :doc:
  return [] unless header
  # Split the comma-separated list into an array of strings.
  ips = header.strip.split(/[,\s]+/)
  ips.select do |ip|
    begin
      # Only return IPs that are valid according to the IPAddr#new method.
      range = IPAddr.new(ip).to_range
      # We want to make sure nobody is sneaking a netmask in.
      range.begin == range.end
    rescue ArgumentError
      nil
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:176</summary>

##### ActionDispatch::RemoteIp::GetIp#filter_proxies

```ruby
def filter_proxies(ips) # :doc:
  ips.reject do |ip|
    @proxies.any? { |proxy| proxy === ip }
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/remote_ip.rb:149
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:22</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:53</summary>

##### ActiveSupport::TaggedLogging::Formatter#tags_text

```ruby
def tags_text
  tags = current_tags
  if tags.any?
    tags.collect { |tag| "[#{tag}] " }.join
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/show_exceptions.rb:31</summary>

##### ActionDispatch::ShowExceptions#call

```ruby
def call(env)
  request = ActionDispatch::Request.new env
  @app.call(env)
rescue Exception => exception
  if request.show_exceptions?
    render_exception(request, exception)
  else
    raise exception
  end
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:38
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/show_exceptions.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:59</summary>

##### ActionDispatch::DebugExceptions#call

```ruby
def call(env)
  request = ActionDispatch::Request.new env
  _, headers, body = response = @app.call(env)

  if headers["X-Cascade"] == "pass"
    body.close if body.respond_to?(:close)
    raise ActionController::RoutingError, "No route matches [#{env['REQUEST_METHOD']}] #{env['PATH_INFO'].inspect}"
  end

  response
rescue Exception => exception
  raise exception unless request.show_exceptions?
  render_exception(request, exception)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/show_exceptions.rb:33
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:11</summary>

##### ActionDispatch::Executor#call

```ruby
def call(env)
  state = @executor.run!
  begin
    response = @app.call(env)
    returned = response << ::Rack::BodyProxy.new(response.pop) { state.complete! }
  ensure
    state.complete! unless returned
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:61
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/reloader.rb:62</summary>

##### ActiveSupport::Reloader.run!

```ruby
def self.run! # :nodoc:
  if check!
    super
  else
    Null
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/reloader.rb:80</summary>

##### ActiveSupport::Reloader.check!

```ruby
def self.check! # :nodoc:
  @should_reload ||= check.call
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/reloader.rb:63
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### #<Class:#<Class:0x00007f817f1fa150>>.check

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/reloader.rb:81
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/evented_file_update_checker.rb:70</summary>

##### ActiveSupport::EventedFileUpdateChecker#updated?

```ruby
def updated?
  @boot_mutex.synchronize do
    if @pid != Process.pid
      boot!
      @pid = Process.pid
      @updated.make_true
    end
  end
  @updated.true?
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application/finisher.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/atomic/mutex_atomic_boolean.rb:27</summary>

##### Concurrent::MutexAtomicBoolean#true?

```ruby
def true?
  synchronize { @value }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/evented_file_update_checker.rb:78
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/synchronization/mutex_lockable_object.rb:37</summary>

##### Concurrent::Synchronization::MutexLockableObject#synchronize

```ruby
def synchronize
  if @__Lock__.owned?
    yield
  else
    @__Lock__.synchronize { yield }
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/atomic/mutex_atomic_boolean.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/application/routes_reloader.rb:10</summary>

##### Rails::Application::RoutesReloader#updated?

```ruby
delegate :execute_if_updated, :execute, :updated?, to: :updater
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application/finisher.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails/application/routes_reloader.rb:29</summary>

##### Rails::Application::RoutesReloader#updater

```ruby
def updater
  @updater ||= ActiveSupport::FileUpdateChecker.new(paths) { reload! }
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application/routes_reloader.rb:10
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:61</summary>

##### ActiveSupport::FileUpdateChecker#updated?

```ruby
def updated?
  current_watched = watched
  if @last_watched.size != current_watched.size
    @watched = current_watched
    true
  else
    current_updated_at = updated_at(current_watched)
    if @last_update_at < current_updated_at
      @watched    = current_watched
      @updated_at = current_updated_at
      true
    else
      false
    end
  end
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application/routes_reloader.rb:10
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:102</summary>

##### ActiveSupport::FileUpdateChecker#watched

```ruby
def watched
  @watched || begin
    all = @files.select { |f| File.exist?(f) }
    all.concat(Dir[@glob]) if @glob
    all
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:62
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:110</summary>

##### ActiveSupport::FileUpdateChecker#updated_at

```ruby
def updated_at(paths)
  @updated_at || max_mtime(paths) || Time.at(0)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:121</summary>

##### ActiveSupport::FileUpdateChecker#max_mtime

```ruby
def max_mtime(paths)
  time_now = Time.now
  max_mtime = nil

  # Time comparisons are performed with #compare_without_coercion because
  # AS redefines these operators in a way that is much slower and does not
  # bring any benefit in this particular code.
  #
  # Read t1.compare_without_coercion(t2) < 0 as t1 < t2.
  paths.each do |path|
    mtime = File.mtime(path)

    next if time_now.compare_without_coercion(mtime) < 0

    if max_mtime.nil? || max_mtime.compare_without_coercion(mtime) < 0
      max_mtime = mtime
    end
  end

  max_mtime
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:111
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/time/calculations.rb:293</summary>

##### Time#compare_with_coercion

```ruby
def compare_with_coercion(other)
  # we're avoiding Time#to_datetime and Time#to_time because they're expensive
  if other.class == Time
    compare_without_coercion(other)
  elsif other.is_a?(Time)
    compare_without_coercion(other.to_time)
  else
    to_datetime <=> other
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/file_update_checker.rb:68
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/evented_file_update_checker.rb:70</summary>

##### ActiveSupport::EventedFileUpdateChecker#updated?

```ruby
def updated?
  @boot_mutex.synchronize do
    if @pid != Process.pid
      boot!
      @pid = Process.pid
      @updated.make_true
    end
  end
  @updated.true?
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/application/finisher.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/atomic/mutex_atomic_boolean.rb:27</summary>

##### Concurrent::MutexAtomicBoolean#true?

```ruby
def true?
  synchronize { @value }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/evented_file_update_checker.rb:78
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/synchronization/mutex_lockable_object.rb:37</summary>

##### Concurrent::Synchronization::MutexLockableObject#synchronize

```ruby
def synchronize
  if @__Lock__.owned?
    yield
  else
    @__Lock__.synchronize { yield }
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/atomic/mutex_atomic_boolean.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/callbacks.rb:24</summary>

##### ActionDispatch::Callbacks#call

```ruby
def call(env)
  error = nil
  result = run_callbacks :call do
    begin
      @app.call(env)
    rescue => error
    end
  end
  raise error if error
  result
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:94</summary>

##### ActiveSupport::Callbacks#run_callbacks

```ruby
def run_callbacks(kind)
  callbacks = __callbacks[kind.to_sym]

  if callbacks.empty?
    yield if block_given?
  else
    env = Filters::Environment.new(self, false, nil)
    next_sequence = callbacks.compile

    invoke_sequence = Proc.new do
      skipped = nil
      while true
        current = next_sequence
        current.invoke_before(env)
        if current.final?
          env.value = !env.halted && (!block_given? || yield)
        elsif current.skip?(env)
          (skipped ||= []) << current
          next_sequence = next_sequence.nested
          next
        else
          next_sequence = next_sequence.nested
          begin
            target, block, method, *arguments = current.expand_call_template(env, invoke_sequence)
            target.send(method, *arguments, &block)
          ensure
            next_sequence = current
          end
        end
        current.invoke_after(env)
        skipped.pop.invoke_after(env) while skipped && skipped.first
        break env.value
      end
    end

    # Common case: no 'around' callbacks defined
    if next_sequence.final?
      next_sequence.invoke_before(env)
      env.value = !env.halted && (!block_given? || yield)
      next_sequence.invoke_after(env)
      env.value
    else
      invoke_sequence.call
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/callbacks.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:124</summary>

##### ActionDispatch::Callbacks#__callbacks

```ruby
redefine_method(name) do
  if instance_variable_defined?(ivar)
    instance_variable_get ivar
  else
    self.class.public_send name
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActionDispatch::Callbacks.__callbacks

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:539</summary>

##### ActiveSupport::Callbacks::CallbackChain#empty?

```ruby
def empty?;       @chain.empty?; end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:97
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:553</summary>

##### ActiveRecord::Migration::CheckPending#call

```ruby
def call(env)
  mtime = ActiveRecord::Base.connection.migration_context.last_migration.mtime.to_i
  if @last_check < mtime
    ActiveRecord::Migration.check_pending!(connection)
    @last_check = mtime
  end
  @app.call(env)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/callbacks.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:89</summary>

##### ActiveRecord::ConnectionHandling.connection

```ruby
def connection
  retrieve_connection
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:554
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:117</summary>

##### ActiveRecord::ConnectionHandling.retrieve_connection

```ruby
def retrieve_connection
  connection_handler.retrieve_connection(connection_specification_name)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:90
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:130</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1011</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection

```ruby
def retrieve_connection(spec_name) #:nodoc:
  pool = retrieve_connection_pool(spec_name)
  raise ConnectionNotEstablished, "No connection pool with '#{spec_name}' found." unless pool
  pool.connection
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1039</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection_pool

```ruby
def retrieve_connection_pool(spec_name)
  owner_to_pool.fetch(spec_name) do
    # Check if a connection was previously established in an ancestor process,
    # which may have been forked.
    if ancestor_pool = pool_from_any_process_for(spec_name)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection(ancestor_pool.spec.to_hash).tap do |pool|
        pool.schema_cache = ancestor_pool.schema_cache if ancestor_pool.schema_cache
      end
    else
      owner_to_pool[spec_name] = nil
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1012
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:168</summary>

##### Concurrent::Map#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:108</summary>

##### Concurrent::Collection::NonConcurrentMapBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:169
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:381</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connection

```ruby
def connection
  @thread_cached_conns[connection_cache_key(@lock_thread || Thread.current)] ||= checkout
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1014
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:667</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connection_cache_key

```ruby
def connection_cache_key(thread)
  thread
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:382
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:382
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:128</summary>

##### ActiveRecord::ConnectionAdapters::AbstractAdapter#migration_context

```ruby
def migration_context # :nodoc:
  MigrationContext.new(migrations_paths)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:554
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:124</summary>

##### ActiveRecord::ConnectionAdapters::AbstractAdapter#migrations_paths

```ruby
def migrations_paths # :nodoc:
  @config[:migrations_paths] || Migrator.migrations_paths
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1004</summary>

##### ActiveRecord::MigrationContext#initialize

```ruby
def initialize(migrations_paths)
  @migrations_paths = migrations_paths
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1078</summary>

##### ActiveRecord::MigrationContext#last_migration

```ruby
def last_migration #:nodoc:
  migrations.last || NullMigration.new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:554
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1086</summary>

##### ActiveRecord::MigrationContext#migrations

```ruby
def migrations
  migrations = migration_files.map do |file|
    version, name, scope = parse_migration_filename(file)
    raise IllegalMigrationNameError.new(file) unless version
    version = version.to_i
    name = name.camelize

    MigrationProxy.new(name, version, file, scope)
  end

  migrations.sort_by(&:version)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1079
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1117</summary>

##### ActiveRecord::MigrationContext#migration_files

```ruby
def migration_files
  paths = Array(migrations_paths)
  Dir[*paths.flat_map { |path| "#{path}/**/[0-9]*_*.rb" }]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1087
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1082</summary>

##### ActiveRecord::MigrationContext#parse_migration_filename

```ruby
def parse_migration_filename(filename) # :nodoc:
  File.basename(filename).scan(Migration::MigrationFilenameRegexp).first
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1088
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:91</summary>

##### String#camelize

```ruby
def camelize(first_letter = :upper)
  case first_letter
  when :upper
    ActiveSupport::Inflector.camelize(self, true)
  when :lower
    ActiveSupport::Inflector.camelize(self, false)
  else
    raise ArgumentError, "Invalid option, use either :upper or :lower."
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1091
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:69</summary>

##### ActiveSupport::Inflector.camelize

```ruby
def camelize(term, uppercase_first_letter = true)
  string = term.to_s
  if uppercase_first_letter
    string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize }
  else
    string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase }
  end
  string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{inflections.acronyms[$2] || $2.capitalize}" }
  string.gsub!("/".freeze, "::".freeze)
  string
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:94
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:76
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:964</summary>

##### ActiveRecord::MigrationProxy#initialize

```ruby
def initialize(name, version, filename, scope)
  super
  @migration = nil
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1093
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1082</summary>

##### ActiveRecord::MigrationContext#parse_migration_filename

```ruby
def parse_migration_filename(filename) # :nodoc:
  File.basename(filename).scan(Migration::MigrationFilenameRegexp).first
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1088
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:91</summary>

##### String#camelize

```ruby
def camelize(first_letter = :upper)
  case first_letter
  when :upper
    ActiveSupport::Inflector.camelize(self, true)
  when :lower
    ActiveSupport::Inflector.camelize(self, false)
  else
    raise ArgumentError, "Invalid option, use either :upper or :lower."
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1091
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:69</summary>

##### ActiveSupport::Inflector.camelize

```ruby
def camelize(term, uppercase_first_letter = true)
  string = term.to_s
  if uppercase_first_letter
    string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize }
  else
    string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase }
  end
  string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{inflections.acronyms[$2] || $2.capitalize}" }
  string.gsub!("/".freeze, "::".freeze)
  string
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:94
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:76
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:964</summary>

##### ActiveRecord::MigrationProxy#initialize

```ruby
def initialize(name, version, filename, scope)
  super
  @migration = nil
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:1093
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:973</summary>

##### ActiveRecord::MigrationProxy#mtime

```ruby
def mtime
  File.mtime filename
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:554
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/head.rb:11</summary>

##### Rack::Head#call

```ruby
def call(env)
  status, headers, body = @app.call(env)

  if env[REQUEST_METHOD] == HEAD
    [
      status, headers, Rack::BodyProxy.new([]) do
        body.close if body.respond_to? :close
      end
    ]
  else
    [status, headers, body]
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/migration.rb:559
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/conditional_get.rb:22</summary>

##### Rack::ConditionalGet#call

```ruby
def call(env)
  case env[REQUEST_METHOD]
  when "GET", "HEAD"
    status, headers, body = @app.call(env)
    headers = Utils::HeaderHash.new(headers)
    if status == 200 && fresh?(env, headers)
      status = 304
      headers.delete(CONTENT_TYPE)
      headers.delete(CONTENT_LENGTH)
      original_body = body
      body = Rack::BodyProxy.new([]) do
        original_body.close if original_body.respond_to?(:close)
      end
    end
    [status, headers, body]
  else
    @app.call(env)
  end
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/head.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:24</summary>

##### Rack::ETag#call

```ruby
def call(env)
  status, headers, body = @app.call(env)

  if etag_status?(status) && etag_body?(body) && !skip_caching?(headers)
    original_body = body
    digest, new_body = digest_body(body)
    body = Rack::BodyProxy.new(new_body) do
      original_body.close if original_body.respond_to?(:close)
    end
    headers[ETAG_STRING] = %(W/"#{digest}") if digest
  end

  unless headers[CACHE_CONTROL]
    if digest
      headers[CACHE_CONTROL] = @cache_control if @cache_control
    else
      headers[CACHE_CONTROL] = @no_cache_control if @no_cache_control
    end
  end

  [status, headers, body]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/conditional_get.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:837</summary>

##### ActionDispatch::Routing::RouteSet#call

```ruby
def call(env)
  req = make_request(env)
  req.path_info = Journey::Router::Utils.normalize_path(req.path_info)
  @router.serve(req)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:407</summary>

##### ActionDispatch::Routing::RouteSet#make_request

```ruby
def make_request(env)
  request_class.new env
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:838
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:403</summary>

##### ActionDispatch::Routing::RouteSet#request_class

```ruby
def request_class
  ActionDispatch::Request
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:59</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:40</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:186</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:34</summary>

##### ActionDispatch::Request#initialize

```ruby
def initialize(env)
  super
  @method            = nil
  @request_method    = nil
  @remote_ip         = nil
  @original_fullpath = nil
  @fullpath          = nil
  @ip                = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/url.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:839
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router/utils.rb:17</summary>

##### ActionDispatch::Journey::Router::Utils.normalize_path

```ruby
def self.normalize_path(path)
  path ||= ""
  encoding = path.encoding
  path = "/#{path}".dup
  path.squeeze!("/".freeze)
  path.sub!(%r{/+\Z}, "".freeze)
  path.gsub!(/(%[a-f0-9]{2})/) { $1.upcase }
  path = "/".dup if path == "".freeze
  path.force_encoding(encoding)
  path
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:839
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:133</summary>

##### Rack::Request::Helpers#path_info=

```ruby
def path_info=(s);   set_header(PATH_INFO, s.to_s)                  end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:839
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:34</summary>

##### ActionDispatch::Journey::Router#serve

```ruby
def serve(req)
  find_routes(req).each do |match, parameters, route|
    set_params  = req.path_parameters
    path_info   = req.path_info
    script_name = req.script_name

    unless route.path.anchored
      req.script_name = (script_name.to_s + match.to_s).chomp("/")
      req.path_info = match.post_match
      req.path_info = "/" + req.path_info unless req.path_info.start_with? "/"
    end

    parameters = route.defaults.merge parameters.transform_values { |val|
      val.dup.force_encoding(::Encoding::UTF_8)
    }

    req.path_parameters = set_params.merge parameters

    status, headers, body = route.app.serve(req)

    if "pass" == headers["X-Cascade"]
      req.script_name     = script_name
      req.path_info       = path_info
      req.path_parameters = set_params
      next
    end

    return [status, headers, body]
  end

  [404, { "X-Cascade" => "pass" }, ["Not Found"]]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:840
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:111</summary>

##### ActionDispatch::Journey::Router#find_routes

```ruby
def find_routes(req)
  routes = filter_routes(req.path_info).concat custom_routes.find_all { |r|
    r.path.match(req.path_info)
  }

  routes =
    if req.head?
      match_head_routes(routes, req)
    else
      match_routes(routes, req)
    end

  routes.sort_by!(&:precedence)

  routes.map! { |r|
    match_data = r.path.match(req.path_info)
    path_parameters = {}
    match_data.names.zip(match_data.captures) { |name, val|
      path_parameters[name.to_sym] = Utils.unescape_uri(val) if val
    }
    [match_data, path_parameters, r]
  }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:106</summary>

##### ActionDispatch::Journey::Router#filter_routes

```ruby
def filter_routes(path)
  return [] unless ast
  simulator.memos(path) { [] }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:94</summary>

##### ActionDispatch::Journey::Router#ast

```ruby
def ast
  routes.ast
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/routes.rb:51</summary>

##### ActionDispatch::Journey::Routes#ast

```ruby
def ast
  @ast ||= begin
    asts = anchored_routes.map(&:ast)
    Nodes::Or.new(asts)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:98</summary>

##### ActionDispatch::Journey::Router#simulator

```ruby
def simulator
  routes.simulator
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:108
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/routes.rb:58</summary>

##### ActionDispatch::Journey::Routes#simulator

```ruby
def simulator
  return if ast.nil?
  @simulator ||= begin
    gtg = GTG::Builder.new(ast).transition_table
    GTG::Simulator.new(gtg)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:99
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/routes.rb:51</summary>

##### ActionDispatch::Journey::Routes#ast

```ruby
def ast
  @ast ||= begin
    asts = anchored_routes.map(&:ast)
    Nodes::Or.new(asts)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/routes.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/simulator.rb:23</summary>

##### ActionDispatch::Journey::GTG::Simulator#memos

```ruby
def memos(string)
  input = StringScanner.new(string)
  state = [0]
  while sym = input.scan(%r([/.?]|[^/.?]+))
    state = tt.move(state, sym)
  end

  acceptance_states = state.find_all { |s|
    tt.accepting? s
  }

  return yield if acceptance_states.empty?

  acceptance_states.flat_map { |x| tt.memo(x) }.compact
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:108
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/transition_table.rb:44</summary>

##### ActionDispatch::Journey::GTG::TransitionTable#move

```ruby
def move(t, a)
  return [] if t.empty?

  regexps = []

  t.map { |s|
    if states = @regexp_states[s]
      regexps.concat states.map { |re, v| re === a ? v : nil }
    end

    if states = @string_states[s]
      states[a]
    end
  }.compact.concat regexps
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/simulator.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/transition_table.rb:44</summary>

##### ActionDispatch::Journey::GTG::TransitionTable#move

```ruby
def move(t, a)
  return [] if t.empty?

  regexps = []

  t.map { |s|
    if states = @regexp_states[s]
      regexps.concat states.map { |re, v| re === a ? v : nil }
    end

    if states = @string_states[s]
      states[a]
    end
  }.compact.concat regexps
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/simulator.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/transition_table.rb:28</summary>

##### ActionDispatch::Journey::GTG::TransitionTable#accepting?

```ruby
def accepting?(state)
  @accepting[state]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/simulator.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/transition_table.rb:36</summary>

##### ActionDispatch::Journey::GTG::TransitionTable#memo

```ruby
def memo(idx)
  @memos[idx]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/gtg/simulator.rb:36
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:102</summary>

##### ActionDispatch::Journey::Router#custom_routes

```ruby
def custom_routes
  routes.custom_routes
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:165</summary>

##### Rack::Request::Helpers#head?

```ruby
def head?;    request_method == HEAD      end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:165
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:425</summary>

##### ActionDispatch::Request#check_method

```ruby
def check_method(name)
  HTTP_METHOD_LOOKUP[name] || raise(ActionController::UnknownHttpMethod, "#{name}, accepted HTTP methods are #{HTTP_METHODS[0...-1].join(', ')}, and #{HTTP_METHODS[-1]}")
  name
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:135
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:151</summary>

##### ActionDispatch::Journey::Router#match_routes

```ruby
def match_routes(routes, req)
  routes.select { |r| r.matches?(req) }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:120
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:162</summary>

##### ActionDispatch::Journey::Route#matches?

```ruby
def matches?(request)
  match_verb(request) &&
  constraints.all? { |method, value|
    case value
    when Regexp, String
      value === request.send(method).to_s
    when Array
      value.include?(request.send(method))
    when TrueClass
      request.send(method).present?
    when FalseClass
      request.send(method).blank?
    else
      value === request.send(method)
    end
  }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:152
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:197</summary>

##### ActionDispatch::Journey::Route#match_verb

```ruby
def match_verb(request)
  @request_method_match.any? { |m| m.call request }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:163
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:18</summary>

##### ActionDispatch::Journey::Route::VerbMatchers::GET.call

```ruby
def self.call(req); req.#{v.downcase}?; end
            end
          eoc
        end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:198
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:162</summary>

##### Rack::Request::Helpers#get?

```ruby
def get?;     request_method == GET       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:162
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:162</summary>

##### ActionDispatch::Journey::Route#matches?

```ruby
def matches?(request)
  match_verb(request) &&
  constraints.all? { |method, value|
    case value
    when Regexp, String
      value === request.send(method).to_s
    when Array
      value.include?(request.send(method))
    when TrueClass
      request.send(method).present?
    when FalseClass
      request.send(method).blank?
    else
      value === request.send(method)
    end
  }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:152
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:197</summary>

##### ActionDispatch::Journey::Route#match_verb

```ruby
def match_verb(request)
  @request_method_match.any? { |m| m.call request }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:163
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:18</summary>

##### ActionDispatch::Journey::Route::VerbMatchers::POST.call

```ruby
def self.call(req); req.#{v.downcase}?; end
            end
          eoc
        end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:198
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:177</summary>

##### Rack::Request::Helpers#post?

```ruby
def post?;    request_method == POST    end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/route.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:177
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:126
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:157</summary>

##### ActionDispatch::Journey::Path::Pattern#match

```ruby
def match(other)
  return unless match = to_regexp.match(other)
  MatchData.new(names, offsets, match)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:126
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:167</summary>

##### ActionDispatch::Journey::Path::Pattern#to_regexp

```ruby
def to_regexp
  @re ||= regexp_visitor.new(@separators, @requirements).accept spec
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:158
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:57</summary>

##### ActionDispatch::Journey::Path::Pattern#names

```ruby
def names
  @names ||= spec.find_all(&:symbol?).map(&:name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:177</summary>

##### ActionDispatch::Journey::Path::Pattern#offsets

```ruby
def offsets
  return @offsets if @offsets

  @offsets = [0]

  spec.find_all(&:symbol?).each do |node|
    node = node.to_sym

    if @requirements.key?(node)
      re = /#{@requirements[node]}|/
      @offsets.push((re.match("").length - 1) + @offsets.last)
    else
      @offsets << @offsets.last
    end
  end

  @offsets
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:129</summary>

##### ActionDispatch::Journey::Path::Pattern::MatchData#initialize

```ruby
def initialize(names, offsets, match)
  @names   = names
  @offsets = offsets
  @match   = match
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:135</summary>

##### ActionDispatch::Journey::Path::Pattern::MatchData#captures

```ruby
def captures
  Array.new(length - 1) { |i| self[i + 1] }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:144</summary>

##### ActionDispatch::Journey::Path::Pattern::MatchData#length

```ruby
def length
  @offsets.length
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:139</summary>

##### ActionDispatch::Journey::Path::Pattern::MatchData#[]

```ruby
def [](x)
  idx = @offsets[x - 1] + x
  @match[idx]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/path/pattern.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:83</summary>

##### ActionDispatch::Http::Parameters#path_parameters

```ruby
def path_parameters
  get_header(PARAMETERS_KEY) || set_header(PARAMETERS_KEY, {})
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:36
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:37
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:38
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:66</summary>

##### ActionDispatch::Http::Parameters#path_parameters=

```ruby
def path_parameters=(parameters) #:nodoc:
  delete_header("action_dispatch.request.parameters")

  parameters = set_binary_encoding(parameters, parameters[:controller], parameters[:action])
  # If any of the path parameters has an invalid encoding then
  # raise since it's likely to trigger errors further on.
  Request::Utils.check_param_encoding(parameters)

  set_header PARAMETERS_KEY, parameters
rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
  raise ActionController::BadRequest.new("Invalid path parameters: #{e.message}")
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:92</summary>

##### Rack::Request::Env#delete_header

```ruby
def delete_header(name)
  @env.delete name
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:89</summary>

##### ActionDispatch::Http::Parameters#set_binary_encoding

```ruby
def set_binary_encoding(params, controller, action)
  return params unless controller && controller.valid_encoding?

  if binary_params_for?(controller, action)
    ActionDispatch::Request::Utils.each_param_value(params) do |param|
      param.force_encoding ::Encoding::ASCII_8BIT
    end
  end
  params
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:69
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:100</summary>

##### ActionDispatch::Http::Parameters#binary_params_for?

```ruby
def binary_params_for?(controller, action)
  controller_class_for(controller).binary_params_for?(action)
rescue NameError
  false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:92
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:84</summary>

##### ActionDispatch::Request#controller_class_for

```ruby
def controller_class_for(name)
  if name
    controller_param = name.underscore
    const_name = "#{controller_param.camelize}Controller"
    ActiveSupport::Dependencies.constantize(const_name)
  else
    PASS_NOT_FOUND
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:127</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:86
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:92</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless /[A-Z-]|::/.match?(camel_cased_word)
  word = camel_cased_word.to_s.gsub("::".freeze, "/".freeze)
  word.gsub!(inflections.acronyms_underscore_regex) { "#{$1 && '_'.freeze }#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2'.freeze)
  word.gsub!(/([a-z\d])([A-Z])/, '\1_\2'.freeze)
  word.tr!("-".freeze, "_".freeze)
  word.downcase!
  word
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:91</summary>

##### String#camelize

```ruby
def camelize(first_letter = :upper)
  case first_letter
  when :upper
    ActiveSupport::Inflector.camelize(self, true)
  when :lower
    ActiveSupport::Inflector.camelize(self, false)
  else
    raise ArgumentError, "Invalid option, use either :upper or :lower."
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:69</summary>

##### ActiveSupport::Inflector.camelize

```ruby
def camelize(term, uppercase_first_letter = true)
  string = term.to_s
  if uppercase_first_letter
    string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize }
  else
    string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase }
  end
  string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{inflections.acronyms[$2] || $2.capitalize}" }
  string.gsub!("/".freeze, "::".freeze)
  string
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:94
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:612</summary>

##### ActiveSupport::Dependencies.constantize

```ruby
def constantize(name)
  Reference.get(name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:580</summary>

##### ActiveSupport::Dependencies::ClassCache#get

```ruby
def get(key)
  key = key.name if key.respond_to?(:name)
  @store[key] ||= Inflector.constantize(key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:139</summary>

##### ActionController::Metal.binary_params_for?

```ruby
def self.binary_params_for?(action) # :nodoc:
  false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/request/utils.rb:29</summary>

##### ActionDispatch::Request::Utils.check_param_encoding

```ruby
def self.check_param_encoding(params)
  case params
  when Array
    params.each { |element| check_param_encoding(element) }
  when Hash
    params.each_value { |value| check_param_encoding(value) }
  when String
    unless params.valid_encoding?
      # Raise Rack::Utils::InvalidParameterError for consistency with Rack.
      # ActionDispatch::Request#GET will re-raise as a BadRequest error.
      raise Rack::Utils::InvalidParameterError, "Invalid encoding for parameter: #{params.scrub}"
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/request/utils.rb:29</summary>

##### ActionDispatch::Request::Utils.check_param_encoding

```ruby
def self.check_param_encoding(params)
  case params
  when Array
    params.each { |element| check_param_encoding(element) }
  when Hash
    params.each_value { |value| check_param_encoding(value) }
  when String
    unless params.valid_encoding?
      # Raise Rack::Utils::InvalidParameterError for consistency with Rack.
      # ActionDispatch::Request#GET will re-raise as a BadRequest error.
      raise Rack::Utils::InvalidParameterError, "Invalid encoding for parameter: #{params.scrub}"
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/request/utils.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/request/utils.rb:29</summary>

##### ActionDispatch::Request::Utils.check_param_encoding

```ruby
def self.check_param_encoding(params)
  case params
  when Array
    params.each { |element| check_param_encoding(element) }
  when Hash
    params.each_value { |value| check_param_encoding(value) }
  when String
    unless params.valid_encoding?
      # Raise Rack::Utils::InvalidParameterError for consistency with Rack.
      # ActionDispatch::Request#GET will re-raise as a BadRequest error.
      raise Rack::Utils::InvalidParameterError, "Invalid encoding for parameter: #{params.scrub}"
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/request/utils.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:74
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:30</summary>

##### ActionDispatch::Routing::RouteSet::Dispatcher#serve

```ruby
def serve(req)
  params     = req.path_parameters
  controller = controller req
  res        = controller.make_response! req
  dispatch(controller, params[:action], req, res)
rescue ActionController::RoutingError
  if @raise_on_name_error
    raise
  else
    return [404, { "X-Cascade" => "pass" }, []]
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/journey/router.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:83</summary>

##### ActionDispatch::Http::Parameters#path_parameters

```ruby
def path_parameters
  get_header(PARAMETERS_KEY) || set_header(PARAMETERS_KEY, {})
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:45</summary>

##### ActionDispatch::Routing::RouteSet::Dispatcher#controller

```ruby
def controller(req)
  req.controller_class
rescue NameError => e
  raise ActionController::RoutingError, e.message, e.backtrace
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:78</summary>

##### ActionDispatch::Request#controller_class

```ruby
def controller_class
  params = path_parameters
  params[:action] ||= "index"
  controller_class_for(params[:controller])
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:46
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:83</summary>

##### ActionDispatch::Http::Parameters#path_parameters

```ruby
def path_parameters
  get_header(PARAMETERS_KEY) || set_header(PARAMETERS_KEY, {})
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:79
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:84</summary>

##### ActionDispatch::Request#controller_class_for

```ruby
def controller_class_for(name)
  if name
    controller_param = name.underscore
    const_name = "#{controller_param.camelize}Controller"
    ActiveSupport::Dependencies.constantize(const_name)
  else
    PASS_NOT_FOUND
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:81
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:127</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:86
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:92</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless /[A-Z-]|::/.match?(camel_cased_word)
  word = camel_cased_word.to_s.gsub("::".freeze, "/".freeze)
  word.gsub!(inflections.acronyms_underscore_regex) { "#{$1 && '_'.freeze }#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2'.freeze)
  word.gsub!(/([a-z\d])([A-Z])/, '\1_\2'.freeze)
  word.tr!("-".freeze, "_".freeze)
  word.downcase!
  word
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:91</summary>

##### String#camelize

```ruby
def camelize(first_letter = :upper)
  case first_letter
  when :upper
    ActiveSupport::Inflector.camelize(self, true)
  when :lower
    ActiveSupport::Inflector.camelize(self, false)
  else
    raise ArgumentError, "Invalid option, use either :upper or :lower."
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:69</summary>

##### ActiveSupport::Inflector.camelize

```ruby
def camelize(term, uppercase_first_letter = true)
  string = term.to_s
  if uppercase_first_letter
    string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize }
  else
    string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase }
  end
  string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{inflections.acronyms[$2] || $2.capitalize}" }
  string.gsub!("/".freeze, "::".freeze)
  string
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:94
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:612</summary>

##### ActiveSupport::Dependencies.constantize

```ruby
def constantize(name)
  Reference.get(name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:580</summary>

##### ActiveSupport::Dependencies::ClassCache#get

```ruby
def get(key)
  key = key.name if key.respond_to?(:name)
  @store[key] ||= Inflector.constantize(key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:133</summary>

##### ActionController::Metal.make_response!

```ruby
def self.make_response!(request)
  ActionDispatch::Response.new.tap do |res|
    res.request = request
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:33
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:164</summary>

##### ActionDispatch::Response#initialize

```ruby
def initialize(status = 200, header = {}, body = [])
  super()

  @header = Header.new(self, header)

  self.body, self.status = body, status

  @cv           = new_cond
  @committed    = false
  @sending      = false
  @sent         = false

  prepare_cache_control!

  yield self if block_given?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:134
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:250</summary>

##### ActionDispatch::Response#initialize

```ruby
def initialize(status = 200, header = {}, body = [])
  super()

  @header = Header.new(self, header)

  self.body, self.status = body, status

  @cv           = new_cond
  @committed    = false
  @sending      = false
  @sent         = false

  prepare_cache_control!

  yield self if block_given?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:165
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:257</summary>

##### MonitorMixin#mon_initialize

```ruby
def mon_initialize
  if defined?(@mon_mutex) && @mon_mutex_owner_object_id == object_id
    raise ThreadError, "already initialized"
  end
  @mon_mutex = Thread::Mutex.new
  @mon_mutex_owner_object_id = object_id
  @mon_owner = nil
  @mon_count = 0
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:39</summary>

##### ActionDispatch::Response::Header#initialize

```ruby
def initialize(response, header)
  @response = response
  super(header)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:167
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:71</summary>

##### ActionDispatch::Response::Header#initialize

```ruby
def initialize(response, header)
  @response = response
  super(header)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:41
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:399</summary>

##### 0x00007f817f2ce220#__setobj__

```ruby
def __setobj__(obj)  # :nodoc:
  __raise__ ::ArgumentError, "cannot delegate to self" if self.equal?(obj)
  @delegate_dc_obj = obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:312</summary>

##### ActionDispatch::Response#body=

```ruby
def body=(body)
  if body.respond_to?(:to_path)
    @stream = body
  else
    synchronize do
      @stream = build_buffer self, munge_body_object(body)
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:169
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:316
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:456</summary>

##### ActionDispatch::Response#munge_body_object

```ruby
def munge_body_object(body)
  body.respond_to?(:each) ? body : [body]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:317
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:452</summary>

##### ActionDispatch::Response#build_buffer

```ruby
def build_buffer(response, body)
  Buffer.new response, body
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:317
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:100</summary>

##### ActionDispatch::Response::Buffer#initialize

```ruby
def initialize(response, buf)
  @response = response
  @buf      = buf
  @closed   = false
  @str_body = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:453
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:224</summary>

##### ActionDispatch::Response#status=

```ruby
def status=(status)
  @status = Rack::Utils.status_code(status)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:169
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:585</summary>

##### Rack::Utils.status_code

```ruby
def status_code(status)
  if status.is_a?(Symbol)
    SYMBOL_TO_STATUS_CODE[status] || 500
  else
    status.to_i
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:225
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:241</summary>

##### MonitorMixin#new_cond

```ruby
def new_cond
  return ConditionVariable.new(self)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:171
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:156</summary>

##### MonitorMixin::ConditionVariable#initialize

```ruby
def initialize(monitor)
  @monitor = monitor
  @cond = Thread::ConditionVariable.new
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:242
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:165</summary>

##### ActionDispatch::Http::Cache::Response#prepare_cache_control!

```ruby
def prepare_cache_control!
  @cache_control = cache_control_headers
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:176
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:147</summary>

##### ActionDispatch::Http::Cache::Response#cache_control_headers

```ruby
def cache_control_headers
  cache_control = {}

  cache_control_segments.each do |segment|
    directive, argument = segment.split("=", 2)

    if SPECIAL_KEYS.include? directive
      key = directive.tr("-", "_")
      cache_control[key.to_sym] = argument || true
    else
      cache_control[:extras] ||= []
      cache_control[:extras] << segment
    end
  end

  cache_control
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:166
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:139</summary>

##### ActionDispatch::Http::Cache::Response#cache_control_segments

```ruby
def cache_control_segments
  if cache_control = _cache_control
    cache_control.delete(" ").split(",")
  else
    []
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:150
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:199</summary>

##### ActionDispatch::Http::Cache::Response#cache_control

```ruby
attr_reader :cache_control
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:140
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:51</summary>

##### ActionDispatch::Routing::RouteSet::Dispatcher#dispatch

```ruby
def dispatch(controller, action, req, res)
  controller.dispatch(action, req, res)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:248</summary>

##### ActionController::Metal.dispatch

```ruby
def self.dispatch(name, req, res)
  if middleware_stack.any?
    middleware_stack.build(name) { |env| new.dispatch(name, req, res) }.call req.env
  else
    new.dispatch(name, req, res)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/route_set.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### BooksController.middleware_stack

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:249
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/stack.rb:50</summary>

##### ActionDispatch::MiddlewareStack#each

```ruby
def each
  @middlewares.each { |x| yield x }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:249
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/url_for.rb:106</summary>

##### ActionDispatch::Routing::UrlFor#initialize

```ruby
def initialize(*)
  @_routes = nil
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:153</summary>

##### ActionDispatch::Routing::UrlFor#initialize

```ruby
def initialize(*)
  @_routes = nil
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/routing/url_for.rb:108
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:188</summary>

##### ActionController::Metal#dispatch

```ruby
def dispatch(name, request, response) #:nodoc:
  set_request!(request)
  set_response!(response)
  process(name)
  request.commit_flash
  to_a
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:252
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:200</summary>

##### ActionController::Metal#set_request!

```ruby
def set_request!(request) #:nodoc:
  @_request = request
  @_request.controller_instance = self
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:189
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:164</summary>

##### ActionDispatch::Request#controller_instance=

```ruby
def controller_instance=(controller) # :nodoc:
  set_header("action_controller.instance".freeze, controller)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:202
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:165
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:196</summary>

##### ActionController::Metal#set_response!

```ruby
def set_response!(response) # :nodoc:
  @_response = response
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:125</summary>

##### AbstractController::Base#process

```ruby
def process(action, *args)
  @_action_name = action.to_s

  unless action_name = _find_action_name(@_action_name)
    raise ActionNotFound, "The action '#{action}' could not be found for #{self.class.name}"
  end

  @_response_body = nil

  process_action(action_name, *args)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:191
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:225</summary>

##### AbstractController::Base#_find_action_name

```ruby
def _find_action_name(action_name)
  _valid_action_name?(action_name) && method_for_action(action_name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:261</summary>

##### AbstractController::Base#_valid_action_name?

```ruby
def _valid_action_name?(action_name)
  !action_name.to_s.include? File::SEPARATOR
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:226
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:252</summary>

##### AbstractController::Base#method_for_action

```ruby
def method_for_action(action_name)
  if action_method?(action_name)
    action_name
  elsif respond_to?(:action_missing, true)
    "_handle_action_missing"
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:226
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:183</summary>

##### AbstractController::Base#action_method?

```ruby
def action_method?(name)
  self.class.action_methods.include?(name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:253
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/url_for.rb:24</summary>

##### AbstractController::UrlFor::ClassMethods.action_methods

```ruby
def action_methods
  @action_methods ||= begin
    if _routes
      super - _routes.named_routes.helper_names
    else
      super
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:184
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:184
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:19</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:134
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:15</summary>

##### ActiveRecord::LogSubscriber.reset_runtime

```ruby
def self.reset_runtime
  rt, self.runtime = runtime, 0
  rt
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:11</summary>

##### ActiveRecord::LogSubscriber.runtime

```ruby
def self.runtime
  ActiveRecord::RuntimeRegistry.sql_runtime ||= 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:7</summary>

##### ActiveRecord::LogSubscriber.runtime=

```ruby
def self.runtime=(value)
  ActiveRecord::RuntimeRegistry.sql_runtime = value
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime=

```ruby
class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/params_wrapper.rb:243</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:24
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/params_wrapper.rb:286</summary>

##### ActionController::ParamsWrapper#_wrapper_enabled?

```ruby
def _wrapper_enabled?
  return false unless request.has_content_type?

  ref = request.content_mime_type.ref
  _wrapper_formats.include?(ref) && _wrapper_key && !request.parameters.key?(_wrapper_key)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/params_wrapper.rb:244
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:30</summary>

##### ActionDispatch::Http::MimeNegotiation#has_content_type?

```ruby
def has_content_type? # :nodoc:
  get_header "CONTENT_TYPE"
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/params_wrapper.rb:287
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:19</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/params_wrapper.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:42</summary>

##### ActionDispatch::Http::FilterParameters#filtered_parameters

```ruby
def filtered_parameters
  @filtered_parameters ||= parameter_filter.filter(parameters)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:58</summary>

##### ActionDispatch::Http::FilterParameters#parameter_filter

```ruby
def parameter_filter # :doc:
  parameter_filter_for fetch_header("action_dispatch.parameter_filter") {
    return NULL_PARAM_FILTER
  }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:58</summary>

##### Rack::Request::Env#fetch_header

```ruby
def fetch_header(name, &block)
  @env.fetch(name, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:71</summary>

##### ActionDispatch::Http::FilterParameters#parameter_filter_for

```ruby
def parameter_filter_for(filters) # :doc:
  ParameterFilter.new(filters)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:10</summary>

##### ActionDispatch::Http::ParameterFilter#initialize

```ruby
def initialize(filters = [])
  @filters = filters
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:50</summary>

##### ActionDispatch::Http::Parameters#parameters

```ruby
def parameters
  params = get_header("action_dispatch.request.parameters")
  return params if params

  params = begin
             request_parameters.merge(query_parameters)
           rescue EOFError
             query_parameters.dup
           end
  params.merge!(path_parameters)
  params = set_binary_encoding(params, params[:controller], params[:action])
  set_header("action_dispatch.request.parameters", params)
  params
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:51
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:379</summary>

##### ActionDispatch::Request#POST

```ruby
def POST
  fetch_header("action_dispatch.request.request_parameters") do
    pr = parse_formatted_parameters(params_parsers) do |params|
      super || {}
    end
    self.request_parameters = Request::Utils.normalize_encode_params(pr)
  end
rescue Http::Parameters::ParseError # one of the parse strategies blew up
  self.request_parameters = Request::Utils.normalize_encode_params(super || {})
  raise
rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
  raise ActionController::BadRequest.new("Invalid request parameters: #{e.message}")
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:58</summary>

##### Rack::Request::Env#fetch_header

```ruby
def fetch_header(name, &block)
  @env.fetch(name, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:380
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:366</summary>

##### ActionDispatch::Request#GET

```ruby
def GET
  fetch_header("action_dispatch.request.query_parameters") do |k|
    rack_query_params = super || {}
    # Check for non UTF-8 parameter values, which would cause errors later
    Request::Utils.check_param_encoding(rack_query_params)
    set_header k, Request::Utils.normalize_encode_params(rack_query_params)
  end
rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e
  raise ActionController::BadRequest.new("Invalid query parameters: #{e.message}")
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:58</summary>

##### Rack::Request::Env#fetch_header

```ruby
def fetch_header(name, &block)
  @env.fetch(name, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:367
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:263</summary>

##### ActiveSupport::HashWithIndifferentAccess#merge

```ruby
def merge(hash, &block)
  dup.update(hash, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:254</summary>

##### ActiveSupport::HashWithIndifferentAccess#dup

```ruby
def dup
  self.class.new(self).tap do |new_hash|
    set_defaults(new_hash)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:264
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:66</summary>

##### ActiveSupport::HashWithIndifferentAccess#initialize

```ruby
def initialize(constructor = {})
  if constructor.respond_to?(:to_hash)
    super()
    update(constructor)

    hash = constructor.to_hash
    self.default = hash.default if hash.default
    self.default_proc = hash.default_proc if hash.default_proc
  else
    super(constructor)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:255
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:123</summary>

##### ActiveSupport::HashWithIndifferentAccess#update

```ruby
def update(other_hash)
  if other_hash.is_a? HashWithIndifferentAccess
    super(other_hash)
  else
    other_hash.to_hash.each_pair do |key, value|
      if block_given? && key?(key)
        value = yield(convert_key(key), self[key], value)
      end
      regular_writer(convert_key(key), convert_value(value))
    end
    self
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:69
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:351</summary>

##### ActiveSupport::HashWithIndifferentAccess#to_hash

```ruby
def to_hash
  _new_hash = Hash.new
  set_defaults(_new_hash)

  each do |key, value|
    _new_hash[key] = convert_value(value, for: :to_hash)
  end
  _new_hash
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:383</summary>

##### ActiveSupport::HashWithIndifferentAccess#set_defaults

```ruby
def set_defaults(target) # :doc:
  if default_proc
    target.default_proc = default_proc.dup
  else
    target.default = default
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:353
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:219</summary>

##### ActiveSupport::HashWithIndifferentAccess#default

```ruby
def default(*args)
  super(*args.map { |arg| convert_key(arg) })
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:387
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:383</summary>

##### ActiveSupport::HashWithIndifferentAccess#set_defaults

```ruby
def set_defaults(target) # :doc:
  if default_proc
    target.default_proc = default_proc.dup
  else
    target.default = default
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:219</summary>

##### ActiveSupport::HashWithIndifferentAccess#default

```ruby
def default(*args)
  super(*args.map { |arg| convert_key(arg) })
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:387
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:123</summary>

##### ActiveSupport::HashWithIndifferentAccess#update

```ruby
def update(other_hash)
  if other_hash.is_a? HashWithIndifferentAccess
    super(other_hash)
  else
    other_hash.to_hash.each_pair do |key, value|
      if block_given? && key?(key)
        value = yield(convert_key(key), self[key], value)
      end
      regular_writer(convert_key(key), convert_value(value))
    end
    self
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:264
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:83</summary>

##### ActionDispatch::Http::Parameters#path_parameters

```ruby
def path_parameters
  get_header(PARAMETERS_KEY) || set_header(PARAMETERS_KEY, {})
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:123</summary>

##### ActiveSupport::HashWithIndifferentAccess#update

```ruby
def update(other_hash)
  if other_hash.is_a? HashWithIndifferentAccess
    super(other_hash)
  else
    other_hash.to_hash.each_pair do |key, value|
      if block_given? && key?(key)
        value = yield(convert_key(key), self[key], value)
      end
      regular_writer(convert_key(key), convert_value(value))
    end
    self
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:162</summary>

##### ActiveSupport::HashWithIndifferentAccess#[]

```ruby
def [](key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:163
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:162</summary>

##### ActiveSupport::HashWithIndifferentAccess#[]

```ruby
def [](key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:163
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:89</summary>

##### ActionDispatch::Http::Parameters#set_binary_encoding

```ruby
def set_binary_encoding(params, controller, action)
  return params unless controller && controller.valid_encoding?

  if binary_params_for?(controller, action)
    ActionDispatch::Request::Utils.each_param_value(params) do |param|
      param.force_encoding ::Encoding::ASCII_8BIT
    end
  end
  params
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:60
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:100</summary>

##### ActionDispatch::Http::Parameters#binary_params_for?

```ruby
def binary_params_for?(controller, action)
  controller_class_for(controller).binary_params_for?(action)
rescue NameError
  false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:92
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:84</summary>

##### ActionDispatch::Request#controller_class_for

```ruby
def controller_class_for(name)
  if name
    controller_param = name.underscore
    const_name = "#{controller_param.camelize}Controller"
    ActiveSupport::Dependencies.constantize(const_name)
  else
    PASS_NOT_FOUND
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:127</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:86
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:92</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless /[A-Z-]|::/.match?(camel_cased_word)
  word = camel_cased_word.to_s.gsub("::".freeze, "/".freeze)
  word.gsub!(inflections.acronyms_underscore_regex) { "#{$1 && '_'.freeze }#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2'.freeze)
  word.gsub!(/([a-z\d])([A-Z])/, '\1_\2'.freeze)
  word.tr!("-".freeze, "_".freeze)
  word.downcase!
  word
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:91</summary>

##### String#camelize

```ruby
def camelize(first_letter = :upper)
  case first_letter
  when :upper
    ActiveSupport::Inflector.camelize(self, true)
  when :lower
    ActiveSupport::Inflector.camelize(self, false)
  else
    raise ArgumentError, "Invalid option, use either :upper or :lower."
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:69</summary>

##### ActiveSupport::Inflector.camelize

```ruby
def camelize(term, uppercase_first_letter = true)
  string = term.to_s
  if uppercase_first_letter
    string = string.sub(/^[a-z\d]*/) { |match| inflections.acronyms[match] || match.capitalize }
  else
    string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase }
  end
  string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{inflections.acronyms[$2] || $2.capitalize}" }
  string.gsub!("/".freeze, "::".freeze)
  string
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/string/inflections.rb:94
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:252</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/methods.rb:72
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:66</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/inflector/inflections.rb:67
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:612</summary>

##### ActiveSupport::Dependencies.constantize

```ruby
def constantize(name)
  Reference.get(name)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:580</summary>

##### ActiveSupport::Dependencies::ClassCache#get

```ruby
def get(key)
  key = key.name if key.respond_to?(:name)
  @store[key] ||= Inflector.constantize(key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/dependencies.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:139</summary>

##### ActionController::Metal.binary_params_for?

```ruby
def self.binary_params_for?(action) # :nodoc:
  false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:68</summary>

##### Rack::Request::Env#set_header

```ruby
def set_header(name, v)
  @env[name] = v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameters.rb:61
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:14</summary>

##### ActionDispatch::Http::ParameterFilter#filter

```ruby
def filter(params)
  compiled_filter.call(params)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/filter_parameters.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:20</summary>

##### ActionDispatch::Http::ParameterFilter#compiled_filter

```ruby
def compiled_filter
  @compiled_filter ||= CompiledFilter.compile(@filters)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:25</summary>

##### ActionDispatch::Http::ParameterFilter::CompiledFilter.compile

```ruby
def self.compile(filters)
  return lambda { |params| params.dup } if filters.empty?

  strings, regexps, blocks = [], [], []

  filters.each do |item|
    case item
    when Proc
      blocks << item
    when Regexp
      regexps << item
    else
      strings << Regexp.escape(item.to_s)
    end
  end

  deep_regexps, regexps = regexps.partition { |r| r.to_s.include?("\\.".freeze) }
  deep_strings, strings = strings.partition { |s| s.include?("\\.".freeze) }

  regexps << Regexp.new(strings.join("|".freeze), true) unless strings.empty?
  deep_regexps << Regexp.new(deep_strings.join("|".freeze), true) unless deep_strings.empty?

  new regexps, deep_regexps, blocks
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:52</summary>

##### ActionDispatch::Http::ParameterFilter::CompiledFilter#initialize

```ruby
def initialize(regexps, deep_regexps, blocks)
  @regexps = regexps
  @deep_regexps = deep_regexps.any? ? deep_regexps : nil
  @blocks = blocks
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:47
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:58</summary>

##### ActionDispatch::Http::ParameterFilter::CompiledFilter#call

```ruby
def call(original_params, parents = [])
  filtered_params = original_params.class.new

  original_params.each do |key, value|
    parents.push(key) if deep_regexps
    if regexps.any? { |r| key =~ r }
      value = FILTERED
    elsif deep_regexps && (joined = parents.join(".")) && deep_regexps.any? { |r| joined =~ r }
      value = FILTERED
    elsif value.is_a?(Hash)
      value = call(value, parents)
    elsif value.is_a?(Array)
      value = value.map { |v| v.is_a?(Hash) ? call(v, parents) : v }
    elsif blocks.any?
      key = key.dup if key.duplicable?
      value = value.dup if value.duplicable?
      blocks.each { |b| b.call(key, value) }
    end
    parents.pop if deep_regexps

    filtered_params[key] = value
  end

  filtered_params
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:66</summary>

##### ActiveSupport::HashWithIndifferentAccess#initialize

```ruby
def initialize(constructor = {})
  if constructor.respond_to?(:to_hash)
    super()
    update(constructor)

    hash = constructor.to_hash
    self.default = hash.default if hash.default
    self.default_proc = hash.default_proc if hash.default_proc
  else
    super(constructor)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:123</summary>

##### ActiveSupport::HashWithIndifferentAccess#update

```ruby
def update(other_hash)
  if other_hash.is_a? HashWithIndifferentAccess
    super(other_hash)
  else
    other_hash.to_hash.each_pair do |key, value|
      if block_given? && key?(key)
        value = yield(convert_key(key), self[key], value)
      end
      regular_writer(convert_key(key), convert_value(value))
    end
    self
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:69
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:92</summary>

##### ActiveSupport::HashWithIndifferentAccess#[]=

```ruby
def []=(key, value)
  regular_writer(convert_key(key), convert_value(value, for: :assignment))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:78
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:93
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:93
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:92</summary>

##### ActiveSupport::HashWithIndifferentAccess#[]=

```ruby
def []=(key, value)
  regular_writer(convert_key(key), convert_value(value, for: :assignment))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/parameter_filter.rb:78
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:93
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:93
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:199</summary>

##### ActionDispatch::Request#headers

```ruby
def headers
  @headers ||= Http::Headers.new(self)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:24
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/headers.rb:54</summary>

##### ActionDispatch::Http::Headers#initialize

```ruby
def initialize(request) # :nodoc:
  @req = request
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:54</summary>

##### ActionDispatch::Http::MimeNegotiation#format

```ruby
def format(view_path = [])
  formats.first || Mime::NullType.instance
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:58</summary>

##### ActionDispatch::Http::MimeNegotiation#formats

```ruby
def formats
  fetch_header("action_dispatch.request.formats") do |k|
    params_readable = begin
                        parameters[:format]
                      rescue ActionController::BadRequest
                        false
                      end

    v = if params_readable
      Array(Mime[parameters[:format]])
    elsif use_accept_header && valid_accept_header
      accepts
    elsif extension_format = format_from_path_extension
      [extension_format]
    elsif xhr?
      [Mime[:js]]
    else
      [Mime[:html]]
    end

    v = v.select do |format|
      format.symbol || format.ref == "*/*"
    end

    set_header k, v
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:58</summary>

##### Rack::Request::Env#fetch_header

```ruby
def fetch_header(name, &block)
  @env.fetch(name, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:244</summary>

##### Mime::Type#ref

```ruby
def ref
  symbol || to_s
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:134</summary>

##### ActionDispatch::Request#request_method

```ruby
def request_method
  @request_method ||= check_method(super)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:238</summary>

##### ActionDispatch::Request#fullpath

```ruby
def fullpath
  @fullpath ||= super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:407</summary>

##### ActionDispatch::Request#fullpath

```ruby
def fullpath
  @fullpath ||= super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:239
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136</summary>

##### Rack::Request::Helpers#query_string

```ruby
def query_string;    get_header(QUERY_STRING).to_s                  end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:136
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:403</summary>

##### Rack::Request::Helpers#path

```ruby
def path
  script_name + path_info
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:408
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129</summary>

##### Rack::Request::Helpers#script_name

```ruby
def script_name;     get_header(SCRIPT_NAME).to_s                   end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132</summary>

##### Rack::Request::Helpers#path_info

```ruby
def path_info;       get_header(PATH_INFO).to_s                     end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:404
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:166</summary>

##### ActiveSupport::Notifications.instrument

```ruby
def instrument(name, payload = {})
  if notifier.listening?(name)
    instrumenter.instrument(name, payload) { yield payload if block_given? }
  else
    yield payload if block_given?
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:63</summary>

##### ActiveSupport::Notifications::Fanout#listening?

```ruby
def listening?(name)
  listeners_for(name).any?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:167
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:64
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:19</summary>

##### ActiveSupport::Notifications::Instrumenter#instrument

```ruby
def instrument(name, payload = {})
  # some of the listeners might have state
  listeners_state = start name, payload
  begin
    yield payload
  rescue Exception => e
    payload[:exception] = [e.class.name, e.message]
    payload[:exception_object] = e
    raise e
  ensure
    finish_with_state listeners_state, name, payload
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:99</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#start

```ruby
def start(name, id, payload)
  @delegate.start name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:79</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:86</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:58</summary>

##### ActiveSupport::Notifications::Event#initialize

```ruby
def initialize(name, start, ending, transaction_id, payload)
  @name           = name
  @payload        = payload.dup
  @time           = start
  @transaction_id = transaction_id
  @end            = ending
  @children       = []
  @duration       = nil
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:43</summary>

##### ActiveSupport::Notifications::Instrumenter#finish_with_state

```ruby
def finish_with_state(listeners_state, name, payload)
  @notifier.finish name, @id, payload, listeners_state
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:47</summary>

##### ActiveSupport::Notifications::Fanout#finish

```ruby
def finish(name, id, payload, listeners = listeners_for(name))
  listeners.each { |s| s.finish(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:103</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#finish

```ruby
def finish(name, id, payload)
  @delegate.finish name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:48
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:83</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:104
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:94</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:7</summary>

##### ActionController::LogSubscriber#start_processing

```ruby
def start_processing(event)
  return unless logger.info?

  payload = event.payload
  params  = payload[:params].except(*INTERNAL_PARAMS)
  format  = payload[:format]
  format  = format.to_s.upcase if format.is_a?(Symbol)

  info "Processing by #{payload[:controller]}##{payload[:action]} as #{format}"
  info "  Parameters: #{params.inspect}" unless params.empty?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:94</summary>

##### ActiveSupport::Logger#info?

```ruby
def #{severity.downcase}?                # def debug?
  Logger::#{severity} >= level           #   DEBUG >= level
end                                      # end
      EOT
    end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:12</summary>

##### Hash#except

```ruby
def except(*keys)
  dup.except!(*keys)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:11
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:254</summary>

##### ActiveSupport::HashWithIndifferentAccess#dup

```ruby
def dup
  self.class.new(self).tap do |new_hash|
    set_defaults(new_hash)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:66</summary>

##### ActiveSupport::HashWithIndifferentAccess#initialize

```ruby
def initialize(constructor = {})
  if constructor.respond_to?(:to_hash)
    super()
    update(constructor)

    hash = constructor.to_hash
    self.default = hash.default if hash.default
    self.default_proc = hash.default_proc if hash.default_proc
  else
    super(constructor)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:255
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:123</summary>

##### ActiveSupport::HashWithIndifferentAccess#update

```ruby
def update(other_hash)
  if other_hash.is_a? HashWithIndifferentAccess
    super(other_hash)
  else
    other_hash.to_hash.each_pair do |key, value|
      if block_given? && key?(key)
        value = yield(convert_key(key), self[key], value)
      end
      regular_writer(convert_key(key), convert_value(value))
    end
    self
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:69
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:351</summary>

##### ActiveSupport::HashWithIndifferentAccess#to_hash

```ruby
def to_hash
  _new_hash = Hash.new
  set_defaults(_new_hash)

  each do |key, value|
    _new_hash[key] = convert_value(value, for: :to_hash)
  end
  _new_hash
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:383</summary>

##### ActiveSupport::HashWithIndifferentAccess#set_defaults

```ruby
def set_defaults(target) # :doc:
  if default_proc
    target.default_proc = default_proc.dup
  else
    target.default = default
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:353
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:219</summary>

##### ActiveSupport::HashWithIndifferentAccess#default

```ruby
def default(*args)
  super(*args.map { |arg| convert_key(arg) })
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:387
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:356
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:366</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_value

```ruby
def convert_value(value, options = {}) # :doc:
  if value.is_a? Hash
    if options[:for] == :to_hash
      value.to_hash
    else
      value.nested_under_indifferent_access
    end
  elsif value.is_a?(Array)
    if options[:for] != :assignment || value.frozen?
      value = value.dup
    end
    value.map! { |e| convert_value(e, options) }
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:356
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:383</summary>

##### ActiveSupport::HashWithIndifferentAccess#set_defaults

```ruby
def set_defaults(target) # :doc:
  if default_proc
    target.default_proc = default_proc.dup
  else
    target.default = default
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:256
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:219</summary>

##### ActiveSupport::HashWithIndifferentAccess#default

```ruby
def default(*args)
  super(*args.map { |arg| convert_key(arg) })
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:387
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:20</summary>

##### Hash#except!

```ruby
def except!(*keys)
  keys.each { |key| delete(key) }
  self
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:293</summary>

##### ActiveSupport::HashWithIndifferentAccess#delete

```ruby
def delete(key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:294
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:293</summary>

##### ActiveSupport::HashWithIndifferentAccess#delete

```ruby
def delete(key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:294
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:293</summary>

##### ActiveSupport::HashWithIndifferentAccess#delete

```ruby
def delete(key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:294
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:293</summary>

##### ActiveSupport::HashWithIndifferentAccess#delete

```ruby
def delete(key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:294
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:293</summary>

##### ActiveSupport::HashWithIndifferentAccess#delete

```ruby
def delete(key)
  super(convert_key(key))
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/hash/except.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:362</summary>

##### ActiveSupport::HashWithIndifferentAccess#convert_key

```ruby
def convert_key(key) # :doc:
  key.kind_of?(Symbol) ? key.to_s : key
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/hash_with_indifferent_access.rb:294
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:95</summary>

##### ActiveSupport::LogSubscriber#info

```ruby
def #{level}(progname = nil, &block)
  logger.#{level}(progname, &block) if logger
end
      METHOD
    end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:524</summary>

##### Logger#info

```ruby
def info(progname = nil, &block)
  add(INFO, nil, progname, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:26</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:525
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::Logger::SimpleFormatter#call

```ruby
def call(severity, timestamp, progname, msg)
  "#{String === msg ? msg : msg.inspect}\n"
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:22</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:53</summary>

##### ActiveSupport::TaggedLogging::Formatter#tags_text

```ruby
def tags_text
  tags = current_tags
  if tags.any?
    tags.collect { |tag| "[#{tag}] " }.join
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:166</summary>

##### ActiveSupport::Notifications.instrument

```ruby
def instrument(name, payload = {})
  if notifier.listening?(name)
    instrumenter.instrument(name, payload) { yield payload if block_given? }
  else
    yield payload if block_given?
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:63</summary>

##### ActiveSupport::Notifications::Fanout#listening?

```ruby
def listening?(name)
  listeners_for(name).any?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:167
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:64
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:19</summary>

##### ActiveSupport::Notifications::Instrumenter#instrument

```ruby
def instrument(name, payload = {})
  # some of the listeners might have state
  listeners_state = start name, payload
  begin
    yield payload
  rescue Exception => e
    payload[:exception] = [e.class.name, e.message]
    payload[:exception_object] = e
    raise e
  ensure
    finish_with_state listeners_state, name, payload
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:99</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#start

```ruby
def start(name, id, payload)
  @delegate.start name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:79</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:86</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:58</summary>

##### ActiveSupport::Notifications::Event#initialize

```ruby
def initialize(name, start, ending, transaction_id, payload)
  @name           = name
  @payload        = payload.dup
  @time           = start
  @transaction_id = transaction_id
  @end            = ending
  @children       = []
  @duration       = nil
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rescue.rb:21</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/callbacks.rb:40</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rescue.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:94</summary>

##### ActiveSupport::Callbacks#run_callbacks

```ruby
def run_callbacks(kind)
  callbacks = __callbacks[kind.to_sym]

  if callbacks.empty?
    yield if block_given?
  else
    env = Filters::Environment.new(self, false, nil)
    next_sequence = callbacks.compile

    invoke_sequence = Proc.new do
      skipped = nil
      while true
        current = next_sequence
        current.invoke_before(env)
        if current.final?
          env.value = !env.halted && (!block_given? || yield)
        elsif current.skip?(env)
          (skipped ||= []) << current
          next_sequence = next_sequence.nested
          next
        else
          next_sequence = next_sequence.nested
          begin
            target, block, method, *arguments = current.expand_call_template(env, invoke_sequence)
            target.send(method, *arguments, &block)
          ensure
            next_sequence = current
          end
        end
        current.invoke_after(env)
        skipped.pop.invoke_after(env) while skipped && skipped.first
        break env.value
      end
    end

    # Common case: no 'around' callbacks defined
    if next_sequence.final?
      next_sequence.invoke_before(env)
      env.value = !env.halted && (!block_given? || yield)
      next_sequence.invoke_after(env)
      env.value
    else
      invoke_sequence.call
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/callbacks.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:124</summary>

##### ActionController::API#__callbacks

```ruby
redefine_method(name) do
  if instance_variable_defined?(ivar)
    instance_variable_get ivar
  else
    self.class.public_send name
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### BooksController.__callbacks

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:128
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:539</summary>

##### ActiveSupport::Callbacks::CallbackChain#empty?

```ruby
def empty?;       @chain.empty?; end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:97
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:563</summary>

##### ActiveSupport::Callbacks::CallbackChain#compile

```ruby
def compile
  @callbacks || @mutex.synchronize do
    final_sequence = CallbackSequence.new
    @callbacks ||= @chain.reverse.inject(final_sequence) do |callback_sequence, callback|
      callback.apply callback_sequence
    end
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:504</summary>

##### ActiveSupport::Callbacks::CallbackSequence#final?

```ruby
def final?
  !@call_template
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:130
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:512</summary>

##### ActiveSupport::Callbacks::CallbackSequence#invoke_before

```ruby
def invoke_before(arg)
  @before.each { |b| b.call(arg) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:403</summary>

##### ActiveSupport::Callbacks::CallTemplate#expand

```ruby
def expand(target, value, block)
  result = @arguments.map { |arg|
    case arg
    when :value; value
    when :target; target
    when :block; block || raise(ArgumentError)
    end
  }

  result.unshift @method_name
  result.unshift @override_block || block
  result.unshift @override_target || target

  # target, block, method, *arguments = result
  # target.send(method, *arguments, &block)
  result
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:425
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/callbacks.rb:74
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:28</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/callbacks.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:58</summary>

##### ActionDispatch::Http::MimeNegotiation#formats

```ruby
def formats
  fetch_header("action_dispatch.request.formats") do |k|
    params_readable = begin
                        parameters[:format]
                      rescue ActionController::BadRequest
                        false
                      end

    v = if params_readable
      Array(Mime[parameters[:format]])
    elsif use_accept_header && valid_accept_header
      accepts
    elsif extension_format = format_from_path_extension
      [extension_format]
    elsif xhr?
      [Mime[:js]]
    else
      [Mime[:html]]
    end

    v = v.select do |format|
      format.symbol || format.ref == "*/*"
    end

    set_header k, v
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:58</summary>

##### Rack::Request::Env#fetch_header

```ruby
def fetch_header(name, &block)
  @env.fetch(name, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:59
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:244</summary>

##### Mime::Type#ref

```ruby
def ref
  symbol || to_s
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:11</summary>

##### ActionView::ViewPaths#formats=

```ruby
delegate :template_exists?, :any_templates?, :view_paths, :formats, :formats=,
         :locale, :locale=, to: :lookup_context
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:40</summary>

##### ActionView::ViewPaths#lookup_context

```ruby
def lookup_context
  @_lookup_context ||=
    ActionView::LookupContext.new(self.class._view_paths, details_for_lookup, _prefixes)
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:11
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActionController::API._view_paths

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:45</summary>

##### ActionView::ViewPaths#details_for_lookup

```ruby
def details_for_lookup
  {}
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:33</summary>

##### ActionView::ViewPaths#_prefixes

```ruby
def _prefixes # :nodoc:
  self.class._prefixes
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:15</summary>

##### ActionView::ViewPaths::ClassMethods._prefixes

```ruby
def _prefixes # :nodoc:
  @_prefixes ||= begin
    return local_prefixes if superclass.abstract?

    local_prefixes + superclass._prefixes
  end
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:222</summary>

##### ActionView::LookupContext#initialize

```ruby
def initialize(view_paths, details = {}, prefixes = [])
  @details_key = nil
  @cache = true
  @prefixes = prefixes
  @rendered_format = nil

  @details = initialize_details({}, details)
  self.view_paths = view_paths
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:236</summary>

##### ActionView::LookupContext#initialize_details

```ruby
def initialize_details(target, details)
  registered_details.each do |k|
    target[k] = details[k] || Accessors::DEFAULT_PROCS[k].call
  end
  target
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:67</summary>

##### ActionView::LookupContext#registered_details

```ruby
def #{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:237
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:54</summary>

##### I18n::Base.locale

```ruby
def #{method}
  config.#{method}
end

def #{method}=(value)
  config.#{method} = (value)
end
      DELEGATORS
    end

    # Tells the backend to reload translations. Used in situations like the
    # Rails development environment. Backends can implement whatever strategy
    # is useful.
    def reload!
      config.clear_available_locales_set
      config.backend.reload!
    end

    # Tells the backend to load translations now. Used in situations like the
    # Rails production environment. Backends can implement whatever strategy
    # is useful.
    def eager_load!
      config.backend.eager_load!
    end

    # Translates, pluralizes and interpolates a given key using a given locale,
    # scope, and default, as well as interpolation values.
    #
    # *LOOKUP*
    #
    # Translation data is organized as a nested hash using the upper-level keys
    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
    #
    # Translations can be looked up at any level of this hash using the key argument
    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
    #
    # Key can be either a single key or a dot-separated key (both Strings and Symbols
    # work). <em>E.g.</em>, the short format can be looked up using both:
    #   I18n.t 'date.formats.short'
    #   I18n.t :'date.formats.short'
    #
    # Scope can be either a single key, a dot-separated key or an array of keys
    # or dot-separated keys. Keys and scopes can be combined freely. So these
    # examples will all look up the same short date format:
    #   I18n.t 'date.formats.short'
    #   I18n.t 'formats.short', :scope => 'date'
    #   I18n.t 'short', :scope => 'date.formats'
    #   I18n.t 'short', :scope => %w(date formats)
    #
    # *INTERPOLATION*
    #
    # Translations can contain interpolation variables which will be replaced by
    # values passed to #translate as part of the options hash, with the keys matching
    # the interpolation variable names.
    #
    # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
    # value for the key +bar+ will be interpolated into the translation:
    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
    #
    # *PLURALIZATION*
    #
    # Translation data can contain pluralized translations. Pluralized translations
    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
    #
    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
    # pluralization rules. Other algorithms can be supported by custom backends.
    #
    # This returns the singular version of a pluralized translation:
    #   I18n.t :foo, :count => 1 # => 'Foo'
    #
    # These both return the plural version of a pluralized translation:
    #   I18n.t :foo, :count => 0 # => 'Foos'
    #   I18n.t :foo, :count => 2 # => 'Foos'
    #
    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
    # <em>E.g.</em>, with the translation
    # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
    # be interpolated to the pluralized translation:
    #   I18n.t :foo, :count => 1 # => '1 foo'
    #
    # *DEFAULTS*
    #
    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
    #   I18n.t :foo, :default => 'default'
    #
    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
    # translation for <tt>:foo</tt> was found:
    #   I18n.t :foo, :default => :bar
    #
    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
    #   I18n.t :foo, :default => [:bar, 'default']
    #
    # *BULK LOOKUP*
    #
    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
    #   I18n.t [:foo, :bar]
    #
    # Can be used with dot-separated nested keys:
    #   I18n.t [:'baz.foo', :'baz.bar']
    #
    # Which is the same as using a scope option:
    #   I18n.t [:foo, :bar], :scope => :baz
    #
    # *LAMBDAS*
    #
    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
    # called and passed the key and options.
    #
    # E.g. assuming the key <tt>:salutation</tt> resolves to:
    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
    #
    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
    #
    # Note that the string returned by lambda will go through string interpolation too,
    # so the following lambda would give the same result:
    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
    #
    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
    # a cache layer is put in front of I18n.translate it will generate a cache key
    # from the argument values passed to #translate. Therefor your lambdas should
    # always return the same translations/values per unique combination of argument
    # values.
    def translate(key = nil, *, throw: false, raise: false, locale: nil, **options) # TODO deprecate :raise
      locale ||= config.locale
      raise Disabled.new('t') if locale == false
      enforce_available_locales!(locale)

      backend = config.backend

      result = catch(:exception) do
if key.is_a?(Array)
  key.map { |k| backend.translate(locale, k, options) }
else
  backend.translate(locale, key, options)
end
      end

      if result.is_a?(MissingTranslation)
handle_exception((throw && :throw || raise && :raise), result, locale, key, options)
      else
result
      end
    end
    alias :t :translate

    # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
    # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
    def translate!(key, options = EMPTY_HASH)
      translate(key, options.merge(:raise => true))
    end
    alias :t! :translate!

    # Returns true if a translation exists for a given key, otherwise returns false.
    def exists?(key, _locale = nil, locale: _locale)
      locale ||= config.locale
      raise Disabled.new('exists?') if locale == false
      raise I18n::ArgumentError if key.is_a?(String) && key.empty?
      config.backend.exists?(locale, key)
    end

    # Transliterates UTF-8 characters to ASCII. By default this method will
    # transliterate only Latin strings to an ASCII approximation:
    #
    #    I18n.transliterate("Ærøskøbing")
    #    # => "AEroskobing"
    #
    #    I18n.transliterate("日本語")
    #    # => "???"
    #
    # It's also possible to add support for per-locale transliterations. I18n
    # expects transliteration rules to be stored at
    # <tt>i18n.transliterate.rule</tt>.
    #
    # Transliteration rules can either be a Hash or a Proc. Procs must accept a
    # single string argument. Hash rules inherit the default transliteration
    # rules, while Procs do not.
    #
    # *Examples*
    #
    # Setting a Hash in <locale>.yml:
    #
    #    i18n:
    #      transliterate:
    #        rule:
    #          ü: "ue"
    #          ö: "oe"
    #
    # Setting a Hash using Ruby:
    #
    #     store_translations(:de, :i18n => {
    #       :transliterate => {
    #         :rule => {
    #           "ü" => "ue",
    #           "ö" => "oe"
    #         }
    #       }
    #     )
    #
    # Setting a Proc:
    #
    #     translit = lambda {|string| MyTransliterator.transliterate(string) }
    #     store_translations(:xx, :i18n => {:transliterate => {:rule => translit})
    #
    # Transliterating strings:
    #
    #     I18n.locale = :en
    #     I18n.transliterate("Jürgen") # => "Jurgen"
    #     I18n.locale = :de
    #     I18n.transliterate("Jürgen") # => "Juergen"
    #     I18n.transliterate("Jürgen", :locale => :en) # => "Jurgen"
    #     I18n.transliterate("Jürgen", :locale => :de) # => "Juergen"
    def transliterate(key, *, throw: false, raise: false, locale: nil, replacement: nil, **options)
      locale ||= config.locale
      raise Disabled.new('transliterate') if locale == false
      enforce_available_locales!(locale)

      config.backend.transliterate(locale, key, replacement)
    rescue I18n::ArgumentError => exception
      handle_exception((throw && :throw || raise && :raise), exception, locale, key, options)
    end

    # Localizes certain objects, such as dates and numbers to local formatting.
    def localize(object, locale: nil, format: nil, **options)
      locale ||= config.locale
      raise Disabled.new('l') if locale == false
      enforce_available_locales!(locale)

      format ||= :default
      config.backend.localize(locale, object, format, options)
    end
    alias :l :localize

    # Executes block with given I18n.locale set.
    def with_locale(tmp_locale = nil)
      if tmp_locale == nil
yield
      else
current_locale = self.locale
self.locale = tmp_locale
begin
  yield
ensure
  self.locale = current_locale
end
      end
    end

    # Merges the given locale, key and scope into a single array of keys.
    # Splits keys that contain dots into multiple keys. Makes sure all
    # keys are Symbols.
    def normalize_keys(locale, key, scope, separator = nil)
      separator ||= I18n.default_separator

      keys = []
      keys.concat normalize_key(locale, separator)
      keys.concat normalize_key(scope, separator)
      keys.concat normalize_key(key, separator)
      keys
    end

    # Returns true when the passed locale, which can be either a String or a
    # Symbol, is in the list of available locales. Returns false otherwise.
    def locale_available?(locale)
      I18n.config.available_locales_set.include?(locale)
    end

    # Raises an InvalidLocale exception when the passed locale is not available.
    def enforce_available_locales!(locale)
      if locale != false && config.enforce_available_locales
raise I18n::InvalidLocale.new(locale) if !locale_available?(locale)
      end
    end

    def available_locales_initialized?
      config.available_locales_initialized?
    end

  private

    # Any exceptions thrown in translate will be sent to the @@exception_handler
    # which can be a Symbol, a Proc or any other Object unless they're forced to
    # be raised or thrown (MissingTranslation).
    #
    # If exception_handler is a Symbol then it will simply be sent to I18n as
    # a method call. A Proc will simply be called. In any other case the
    # method #call will be called on the exception_handler object.
    #
    # Examples:
    #
    #   I18n.exception_handler = :custom_exception_handler              # this is the default
    #   I18n.custom_exception_handler(exception, locale, key, options)  # will be called like this
    #
    #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
    #
    #   I18n.exception_handler = I18nExceptionHandler.new               # an object
    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
    def handle_exception(handling, exception, locale, key, options)
      case handling
      when :raise
raise exception.respond_to?(:to_exception) ? exception.to_exception : exception
      when :throw
throw :exception, exception
      else
case handler = options[:exception_handler] || config.exception_handler
when Symbol
  send(handler, exception, locale, key, options)
else
  handler.call(exception, locale, key, options)
end
      end
    end

    @@normalized_key_cache = I18n.new_double_nested_cache

    def normalize_key(key, separator)
      @@normalized_key_cache[separator][key] ||=
case key
when Array
  key.map { |k| normalize_key(k, separator) }.flatten
else
  keys = key.to_s.split(separator)
  keys.delete('')
  keys.map! do |k|
    case k
    when /\A[-+]?[1-9]\d*\z/ # integer
      k.to_i
    when 'true'
      true
    when 'false'
      false
    else
      k.to_sym
    end
  end
  keys
end
    end
  end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:46
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:41</summary>

##### I18n::Base.config

```ruby
def config
  Thread.current[:i18n_config] ||= I18n::Config.new
end
# called from vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n/config.rb:9</summary>

##### I18n::Config#locale

```ruby
def locale
  defined?(@locale) && @locale != nil ? @locale : default_locale
end
# called from vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n/config.rb:30</summary>

##### I18n::Config#default_locale

```ruby
def default_locale
  @@default_locale ||= :en
end
# called from vendor/bundle/gems/i18n-1.6.0/lib/i18n/config.rb:10
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:54</summary>

##### I18n::Base.default_locale

```ruby
def #{method}
  config.#{method}
end

def #{method}=(value)
  config.#{method} = (value)
end
      DELEGATORS
    end

    # Tells the backend to reload translations. Used in situations like the
    # Rails development environment. Backends can implement whatever strategy
    # is useful.
    def reload!
      config.clear_available_locales_set
      config.backend.reload!
    end

    # Tells the backend to load translations now. Used in situations like the
    # Rails production environment. Backends can implement whatever strategy
    # is useful.
    def eager_load!
      config.backend.eager_load!
    end

    # Translates, pluralizes and interpolates a given key using a given locale,
    # scope, and default, as well as interpolation values.
    #
    # *LOOKUP*
    #
    # Translation data is organized as a nested hash using the upper-level keys
    # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
    # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
    #
    # Translations can be looked up at any level of this hash using the key argument
    # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
    # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
    #
    # Key can be either a single key or a dot-separated key (both Strings and Symbols
    # work). <em>E.g.</em>, the short format can be looked up using both:
    #   I18n.t 'date.formats.short'
    #   I18n.t :'date.formats.short'
    #
    # Scope can be either a single key, a dot-separated key or an array of keys
    # or dot-separated keys. Keys and scopes can be combined freely. So these
    # examples will all look up the same short date format:
    #   I18n.t 'date.formats.short'
    #   I18n.t 'formats.short', :scope => 'date'
    #   I18n.t 'short', :scope => 'date.formats'
    #   I18n.t 'short', :scope => %w(date formats)
    #
    # *INTERPOLATION*
    #
    # Translations can contain interpolation variables which will be replaced by
    # values passed to #translate as part of the options hash, with the keys matching
    # the interpolation variable names.
    #
    # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
    # value for the key +bar+ will be interpolated into the translation:
    #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
    #
    # *PLURALIZATION*
    #
    # Translation data can contain pluralized translations. Pluralized translations
    # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
    #
    # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
    # pluralization rules. Other algorithms can be supported by custom backends.
    #
    # This returns the singular version of a pluralized translation:
    #   I18n.t :foo, :count => 1 # => 'Foo'
    #
    # These both return the plural version of a pluralized translation:
    #   I18n.t :foo, :count => 0 # => 'Foos'
    #   I18n.t :foo, :count => 2 # => 'Foos'
    #
    # The <tt>:count</tt> option can be used both for pluralization and interpolation.
    # <em>E.g.</em>, with the translation
    # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
    # be interpolated to the pluralized translation:
    #   I18n.t :foo, :count => 1 # => '1 foo'
    #
    # *DEFAULTS*
    #
    # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
    #   I18n.t :foo, :default => 'default'
    #
    # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
    # translation for <tt>:foo</tt> was found:
    #   I18n.t :foo, :default => :bar
    #
    # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
    # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
    #   I18n.t :foo, :default => [:bar, 'default']
    #
    # *BULK LOOKUP*
    #
    # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
    #   I18n.t [:foo, :bar]
    #
    # Can be used with dot-separated nested keys:
    #   I18n.t [:'baz.foo', :'baz.bar']
    #
    # Which is the same as using a scope option:
    #   I18n.t [:foo, :bar], :scope => :baz
    #
    # *LAMBDAS*
    #
    # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
    # called and passed the key and options.
    #
    # E.g. assuming the key <tt>:salutation</tt> resolves to:
    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
    #
    # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
    #
    # Note that the string returned by lambda will go through string interpolation too,
    # so the following lambda would give the same result:
    #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
    #
    # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
    # a cache layer is put in front of I18n.translate it will generate a cache key
    # from the argument values passed to #translate. Therefor your lambdas should
    # always return the same translations/values per unique combination of argument
    # values.
    def translate(key = nil, *, throw: false, raise: false, locale: nil, **options) # TODO deprecate :raise
      locale ||= config.locale
      raise Disabled.new('t') if locale == false
      enforce_available_locales!(locale)

      backend = config.backend

      result = catch(:exception) do
if key.is_a?(Array)
  key.map { |k| backend.translate(locale, k, options) }
else
  backend.translate(locale, key, options)
end
      end

      if result.is_a?(MissingTranslation)
handle_exception((throw && :throw || raise && :raise), result, locale, key, options)
      else
result
      end
    end
    alias :t :translate

    # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
    # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
    def translate!(key, options = EMPTY_HASH)
      translate(key, options.merge(:raise => true))
    end
    alias :t! :translate!

    # Returns true if a translation exists for a given key, otherwise returns false.
    def exists?(key, _locale = nil, locale: _locale)
      locale ||= config.locale
      raise Disabled.new('exists?') if locale == false
      raise I18n::ArgumentError if key.is_a?(String) && key.empty?
      config.backend.exists?(locale, key)
    end

    # Transliterates UTF-8 characters to ASCII. By default this method will
    # transliterate only Latin strings to an ASCII approximation:
    #
    #    I18n.transliterate("Ærøskøbing")
    #    # => "AEroskobing"
    #
    #    I18n.transliterate("日本語")
    #    # => "???"
    #
    # It's also possible to add support for per-locale transliterations. I18n
    # expects transliteration rules to be stored at
    # <tt>i18n.transliterate.rule</tt>.
    #
    # Transliteration rules can either be a Hash or a Proc. Procs must accept a
    # single string argument. Hash rules inherit the default transliteration
    # rules, while Procs do not.
    #
    # *Examples*
    #
    # Setting a Hash in <locale>.yml:
    #
    #    i18n:
    #      transliterate:
    #        rule:
    #          ü: "ue"
    #          ö: "oe"
    #
    # Setting a Hash using Ruby:
    #
    #     store_translations(:de, :i18n => {
    #       :transliterate => {
    #         :rule => {
    #           "ü" => "ue",
    #           "ö" => "oe"
    #         }
    #       }
    #     )
    #
    # Setting a Proc:
    #
    #     translit = lambda {|string| MyTransliterator.transliterate(string) }
    #     store_translations(:xx, :i18n => {:transliterate => {:rule => translit})
    #
    # Transliterating strings:
    #
    #     I18n.locale = :en
    #     I18n.transliterate("Jürgen") # => "Jurgen"
    #     I18n.locale = :de
    #     I18n.transliterate("Jürgen") # => "Juergen"
    #     I18n.transliterate("Jürgen", :locale => :en) # => "Jurgen"
    #     I18n.transliterate("Jürgen", :locale => :de) # => "Juergen"
    def transliterate(key, *, throw: false, raise: false, locale: nil, replacement: nil, **options)
      locale ||= config.locale
      raise Disabled.new('transliterate') if locale == false
      enforce_available_locales!(locale)

      config.backend.transliterate(locale, key, replacement)
    rescue I18n::ArgumentError => exception
      handle_exception((throw && :throw || raise && :raise), exception, locale, key, options)
    end

    # Localizes certain objects, such as dates and numbers to local formatting.
    def localize(object, locale: nil, format: nil, **options)
      locale ||= config.locale
      raise Disabled.new('l') if locale == false
      enforce_available_locales!(locale)

      format ||= :default
      config.backend.localize(locale, object, format, options)
    end
    alias :l :localize

    # Executes block with given I18n.locale set.
    def with_locale(tmp_locale = nil)
      if tmp_locale == nil
yield
      else
current_locale = self.locale
self.locale = tmp_locale
begin
  yield
ensure
  self.locale = current_locale
end
      end
    end

    # Merges the given locale, key and scope into a single array of keys.
    # Splits keys that contain dots into multiple keys. Makes sure all
    # keys are Symbols.
    def normalize_keys(locale, key, scope, separator = nil)
      separator ||= I18n.default_separator

      keys = []
      keys.concat normalize_key(locale, separator)
      keys.concat normalize_key(scope, separator)
      keys.concat normalize_key(key, separator)
      keys
    end

    # Returns true when the passed locale, which can be either a String or a
    # Symbol, is in the list of available locales. Returns false otherwise.
    def locale_available?(locale)
      I18n.config.available_locales_set.include?(locale)
    end

    # Raises an InvalidLocale exception when the passed locale is not available.
    def enforce_available_locales!(locale)
      if locale != false && config.enforce_available_locales
raise I18n::InvalidLocale.new(locale) if !locale_available?(locale)
      end
    end

    def available_locales_initialized?
      config.available_locales_initialized?
    end

  private

    # Any exceptions thrown in translate will be sent to the @@exception_handler
    # which can be a Symbol, a Proc or any other Object unless they're forced to
    # be raised or thrown (MissingTranslation).
    #
    # If exception_handler is a Symbol then it will simply be sent to I18n as
    # a method call. A Proc will simply be called. In any other case the
    # method #call will be called on the exception_handler object.
    #
    # Examples:
    #
    #   I18n.exception_handler = :custom_exception_handler              # this is the default
    #   I18n.custom_exception_handler(exception, locale, key, options)  # will be called like this
    #
    #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
    #
    #   I18n.exception_handler = I18nExceptionHandler.new               # an object
    #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
    def handle_exception(handling, exception, locale, key, options)
      case handling
      when :raise
raise exception.respond_to?(:to_exception) ? exception.to_exception : exception
      when :throw
throw :exception, exception
      else
case handler = options[:exception_handler] || config.exception_handler
when Symbol
  send(handler, exception, locale, key, options)
else
  handler.call(exception, locale, key, options)
end
      end
    end

    @@normalized_key_cache = I18n.new_double_nested_cache

    def normalize_key(key, separator)
      @@normalized_key_cache[separator][key] ||=
case key
when Array
  key.map { |k| normalize_key(k, separator) }.flatten
else
  keys = key.to_s.split(separator)
  keys.delete('')
  keys.map! do |k|
    case k
    when /\A[-+]?[1-9]\d*\z/ # integer
      k.to_i
    when 'true'
      true
    when 'false'
      false
    else
      k.to_sym
    end
  end
  keys
end
    end
  end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:48
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:41</summary>

##### I18n::Base.config

```ruby
def config
  Thread.current[:i18n_config] ||= I18n::Config.new
end
# called from vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/i18n-1.6.0/lib/i18n/config.rb:30</summary>

##### I18n::Config#default_locale

```ruby
def default_locale
  @@default_locale ||= :en
end
# called from vendor/bundle/gems/i18n-1.6.0/lib/i18n.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActionView::Base.default_formats

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/template/handlers.rb:23</summary>

##### ActionView::Template::Handlers.extensions

```ruby
def self.extensions
  @@template_extensions ||= @@template_handlers.keys
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:111</summary>

##### ActionView::LookupContext::ViewPaths#view_paths=

```ruby
def view_paths=(paths)
  @view_paths = ActionView::PathSet.new(Array(paths))
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:229
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/path_set.rb:27</summary>

##### ActionView::PathSet#to_ary

```ruby
def to_ary
  paths.dup
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/path_set.rb:18</summary>

##### ActionView::PathSet#initialize

```ruby
def initialize(paths = [])
  @paths = typecast paths
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/path_set.rb:89</summary>

##### ActionView::PathSet#typecast

```ruby
def typecast(paths)
  paths.map do |path|
    case path
    when Pathname, String
      OptimizedFileSystemResolver.new path.to_s
    else
      path
    end
  end
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/path_set.rb:19
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:246</summary>

##### ActionView::LookupContext#formats=

```ruby
def formats=(values)
  if values
    values.concat(default_formats) if values.delete "*/*".freeze
    if values == [:js]
      values << :html
      @html_fallback_for_js = true
    end
  end
  super(values)
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/view_paths.rb:11
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:33</summary>

##### ActionView::LookupContext#formats=

```ruby
def formats=(values)
  if values
    values.concat(default_formats) if values.delete "*/*".freeze
    if values == [:js]
      values << :html
      @html_fallback_for_js = true
    end
  end
  super(values)
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:254
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:26</summary>

##### Object#present?

```ruby
def present?
  !blank?
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:98</summary>

##### ActionView::LookupContext::DetailsCache#_set_detail

```ruby
def _set_detail(key, value) # :doc:
  @details = @details.dup if @details_key
  @details_key = nil
  @details[key] = value
end
# called from vendor/bundle/gems/actionview-5.2.3/lib/action_view/lookup_context.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:193</summary>

##### ActiveRecord::Railties::ControllerRuntime#process_action

```ruby
def process_action(action, *args)
  # We also need to reset the runtime before each action
  # because of queries in middleware or in cases we are streaming
  # and it won't be cleaned up by the method below.
  ActiveRecord::LogSubscriber.reset_runtime
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/basic_implicit_render.rb:5</summary>

##### ActionController::BasicImplicitRender#send_action

```ruby
def send_action(method, *args)
  super.tap { default_render unless performed? }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/base.rb:194
```
</details>
<details open>
<summary>app/controllers/books_controller.rb:5</summary>

##### BooksController#index

```ruby
def index
  @books = Book.all

  render json: @books
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/basic_implicit_render.rb:6
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:26</summary>

##### ActiveRecord::Scoping::Named::ClassMethods.all

```ruby
def all
  current_scope = self.current_scope

  if current_scope
    if self == current_scope.klass
      current_scope.clone
    else
      relation.merge!(current_scope)
    end
  else
    default_scoped
  end
end
# called from app/controllers/books_controller.rb:6
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:15</summary>

##### ActiveRecord::Scoping::ClassMethods.current_scope

```ruby
def current_scope(skip_inherited_scope = false)
  ScopeRegistry.value_for(:current_scope, self, skip_inherited_scope)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55</summary>

##### ActiveRecord::Scoping::ScopeRegistry.value_for

```ruby
singleton_class.delegate name, to: :instance
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:79</summary>

##### ActiveRecord::Scoping::ScopeRegistry#value_for

```ruby
def value_for(scope_type, model, skip_inherited_scope = false)
  raise_invalid_scope_type!(scope_type)
  return @registry[scope_type][model.name] if skip_inherited_scope
  klass = model
  base = model.base_class
  while klass <= base
    value = @registry[scope_type][klass.name]
    return value if value
    klass = klass.superclass
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:99</summary>

##### ActiveRecord::Scoping::ScopeRegistry#raise_invalid_scope_type!

```ruby
def raise_invalid_scope_type!(scope_type)
  if !VALID_SCOPE_TYPES.include?(scope_type)
    raise ArgumentError, "Invalid scope type '#{scope_type}' sent to the registry. Scope types must be included in VALID_SCOPE_TYPES"
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/inheritance.rb:95</summary>

##### ActiveRecord::Inheritance::ClassMethods.base_class

```ruby
def base_class
  unless self < Base
    raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
  end

  if superclass == Base || superclass.abstract_class?
    self
  else
    superclass.base_class
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping.rb:83
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/inheritance.rb:151</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/inheritance.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:284</summary>

##### ActiveRecord::Core::ClassMethods.relation

```ruby
def relation
  relation = Relation.create(self)

  if finder_needs_type_condition? && !ignore_default_scope?
    relation.where!(type_condition)
    relation.create_with!(inheritance_column.to_s => sti_name)
  else
    relation
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:50
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:131</summary>

##### ActiveRecord::Delegation::ClassMethods.create

```ruby
def create(klass, *args)
  relation_class_for(klass).new(klass, *args)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:285
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:137</summary>

##### ActiveRecord::Delegation::ClassMethods.relation_class_for

```ruby
def relation_class_for(klass)
  klass.relation_delegate_class(self)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:6</summary>

##### ActiveRecord::Delegation::DelegateCache.relation_delegate_class

```ruby
def relation_delegate_class(klass)
  @relation_delegate_cache[klass]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:138
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:260</summary>

##### ActiveRecord::Core::ClassMethods.arel_table

```ruby
def arel_table # :nodoc:
  @arel_table ||= Arel::Table.new(table_name, type_caster: type_caster)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:269</summary>

##### ActiveRecord::Core::ClassMethods.predicate_builder

```ruby
def predicate_builder # :nodoc:
  @predicate_builder ||= PredicateBuilder.new(table_metadata)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:25</summary>

##### ActiveRecord::Relation#initialize

```ruby
def initialize(klass, table: klass.arel_table, predicate_builder: klass.predicate_builder, values: {})
  @klass  = klass
  @table  = table
  @values = values
  @offsets = {}
  @loaded = false
  @predicate_builder = predicate_builder
  @delegate_to_klass = false
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:132
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/inheritance.rb:82</summary>

##### ActiveRecord::Inheritance::ClassMethods.finder_needs_type_condition?

```ruby
def finder_needs_type_condition? #:nodoc:
  # This is like this because benchmarking justifies the strange :false stuff
  :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:287
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:50</summary>

##### ActiveRecord::Scoping::Named::ClassMethods.default_scoped

```ruby
def default_scoped(scope = relation) # :nodoc:
  build_default_scope(scope) || scope
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:36
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/default.rb:103</summary>

##### ActiveRecord::Scoping::Default::ClassMethods.build_default_scope

```ruby
def build_default_scope(base_rel = nil)
  return if abstract_class?

  if default_scope_override.nil?
    self.default_scope_override = !Base.is_a?(method(:default_scope).owner)
  end

  if default_scope_override
    # The user has defined their own default scope method, so call that
    evaluate_default_scope do
      if scope = default_scope
        (base_rel ||= relation).merge!(scope)
      end
    end
  elsif default_scopes.any?
    base_rel ||= relation
    evaluate_default_scope do
      default_scopes.inject(base_rel) do |default_scope, scope|
        scope = scope.respond_to?(:to_proc) ? scope : scope.method(:call)
        default_scope.merge!(base_rel.instance_exec(&scope))
      end
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/named.rb:51
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/inheritance.rb:151</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/default.rb:104
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### Book.default_scope_override

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/default.rb:106
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### Book.default_scope_override

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/default.rb:110
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_scopes

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/scoping/default.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:43</summary>

##### ActionController::Instrumentation#render

```ruby
def render(*args)
  render_output = nil
  self.view_runtime = cleanup_view_runtime do
    Benchmark.ms { render_output = super }
  end
  render_output
end
# called from app/controllers/books_controller.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:27</summary>

##### ActiveRecord::Railties::ControllerRuntime#cleanup_view_runtime

```ruby
def cleanup_view_runtime
  if logger && logger.info? && ActiveRecord::Base.connected?
    db_rt_before_render = ActiveRecord::LogSubscriber.reset_runtime
    self.db_runtime = (db_runtime || 0) + db_rt_before_render
    runtime = super
    db_rt_after_render = ActiveRecord::LogSubscriber.reset_runtime
    self.db_runtime += db_rt_after_render
    runtime - db_rt_after_render
  else
    super
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:45
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::API#logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:146</summary>

##### ActiveSupport::Configurable#config

```ruby
def config
  @_config ||= self.class.config.inheritable_copy
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:147
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/ordered_options.rb:81</summary>

##### ActiveSupport::InheritableOptions#inheritable_copy

```ruby
def inheritable_copy
  self.class.new(self)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:147
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/ordered_options.rb:70</summary>

##### ActiveSupport::InheritableOptions#initialize

```ruby
def initialize(parent = nil)
  if parent.kind_of?(OrderedOptions)
    # use the faster _get when dealing with OrderedOptions
    super() { |h, k| parent._get(k) }
  elsif parent
    super() { |h, k| parent[k] }
  else
    super()
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/ordered_options.rb:82
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::API#logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:146</summary>

##### ActiveSupport::Configurable#config

```ruby
def config
  @_config ||= self.class.config.inheritable_copy
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:94</summary>

##### ActiveSupport::Logger#info?

```ruby
def #{severity.downcase}?                # def debug?
  Logger::#{severity} >= level           #   DEBUG >= level
end                                      # end
      EOT
    end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:122</summary>

##### ActiveRecord::ConnectionHandling.connected?

```ruby
def connected?
  connection_handler.connected?(connection_specification_name)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:130</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1019</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#connected?

```ruby
def connected?(spec_name)
  conn = retrieve_connection_pool(spec_name)
  conn && conn.connected?
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1039</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection_pool

```ruby
def retrieve_connection_pool(spec_name)
  owner_to_pool.fetch(spec_name) do
    # Check if a connection was previously established in an ancestor process,
    # which may have been forked.
    if ancestor_pool = pool_from_any_process_for(spec_name)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection(ancestor_pool.spec.to_hash).tap do |pool|
        pool.schema_cache = ancestor_pool.schema_cache if ancestor_pool.schema_cache
      end
    else
      owner_to_pool[spec_name] = nil
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1020
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:168</summary>

##### Concurrent::Map#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:108</summary>

##### Concurrent::Collection::NonConcurrentMapBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:169
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:422</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connected?

```ruby
def connected?
  synchronize { @connections.any? }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1021
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:15</summary>

##### ActiveRecord::LogSubscriber.reset_runtime

```ruby
def self.reset_runtime
  rt, self.runtime = runtime, 0
  rt
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:11</summary>

##### ActiveRecord::LogSubscriber.runtime

```ruby
def self.runtime
  ActiveRecord::RuntimeRegistry.sql_runtime ||= 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:7</summary>

##### ActiveRecord::LogSubscriber.runtime=

```ruby
def self.runtime=(value)
  ActiveRecord::RuntimeRegistry.sql_runtime = value
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime=

```ruby
class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:86</summary>

##### ActiveRecord::Railties::ControllerRuntime#cleanup_view_runtime

```ruby
def cleanup_view_runtime
  if logger && logger.info? && ActiveRecord::Base.connected?
    db_rt_before_render = ActiveRecord::LogSubscriber.reset_runtime
    self.db_runtime = (db_runtime || 0) + db_rt_before_render
    runtime = super
    db_rt_after_render = ActiveRecord::LogSubscriber.reset_runtime
    self.db_runtime += db_rt_after_render
    runtime - db_rt_after_render
  else
    super
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/benchmark.rb:13</summary>

##### Benchmark.ms

```ruby
def ms
  1000 * realtime { yield }
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:46
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/benchmark.rb:306</summary>

##### Benchmark.realtime

```ruby
def realtime # :yield:
  r0 = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  yield
  Process.clock_gettime(Process::CLOCK_MONOTONIC) - r0
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/benchmark.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:34</summary>

##### ActionController::Instrumentation#render

```ruby
def render(*args)
  render_output = nil
  self.view_runtime = cleanup_view_runtime do
    Benchmark.ms { render_output = super }
  end
  render_output
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:46
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:23</summary>

##### ActionController::Instrumentation#render

```ruby
def render(*args)
  render_output = nil
  self.view_runtime = cleanup_view_runtime do
    Benchmark.ms { render_output = super }
  end
  render_output
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:36
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:116</summary>

##### AbstractController::Rendering#_normalize_render

```ruby
def _normalize_render(*args, &block) # :nodoc:
  options = _normalize_args(*args, &block)
  _process_variant(options)
  _normalize_options(options)
  options
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:24
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:82</summary>

##### ActionController::Rendering#_normalize_args

```ruby
def _normalize_args(action = nil, options = {}, &blk)
  options = super
  options[:update] = blk if block_given?
  options
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:117
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:78</summary>

##### ActionController::Rendering#_normalize_args

```ruby
def _normalize_args(action = nil, options = {}, &blk)
  options = super
  options[:update] = blk if block_given?
  options
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:83
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:57</summary>

##### ActionController::Rendering#_process_variant

```ruby
def _process_variant(options)
  if defined?(request) && !request.nil? && request.variant.present?
    options[:variant] = request.variant
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_negotiation.rb:100</summary>

##### ActionDispatch::Http::MimeNegotiation#variant

```ruby
def variant
  @variant ||= ActiveSupport::ArrayInquirer.new
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:58
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:26</summary>

##### Object#present?

```ruby
def present?
  !blank?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:58
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:89</summary>

##### ActionController::Rendering#_normalize_options

```ruby
def _normalize_options(options)
  _normalize_text(options)

  if options[:html]
    options[:html] = ERB::Util.html_escape(options[:html])
  end

  if options[:status]
    options[:status] = Rack::Utils.status_code(options[:status])
  end

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:119
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:103</summary>

##### ActionController::Rendering#_normalize_text

```ruby
def _normalize_text(options)
  RENDER_FORMATS_IN_PRIORITY.each do |format|
    if options.key?(format) && options[format].respond_to?(:to_text)
      options[format] = options[format].to_text
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:90
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:93</summary>

##### ActionController::Rendering#_normalize_options

```ruby
def _normalize_options(options)
  _normalize_text(options)

  if options[:html]
    options[:html] = ERB::Util.html_escape(options[:html])
  end

  if options[:status]
    options[:status] = Rack::Utils.status_code(options[:status])
  end

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:141</summary>

##### ActionController::Renderers#render_to_body

```ruby
def render_to_body(options)
  _render_to_body_with_renderer(options) || super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:145</summary>

##### ActionController::Renderers#_render_to_body_with_renderer

```ruby
def _render_to_body_with_renderer(options)
  _renderers.each do |name|
    if options.key?(name)
      _process_options(options)
      method_name = Renderers._render_with_renderer_method_name(name)
      return send(method_name, options.delete(name), options)
    end
  end
  nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:142
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:124</summary>

##### ActionController::API#_renderers

```ruby
redefine_method(name) do
  if instance_variable_defined?(ivar)
    instance_variable_get ivar
  else
    self.class.public_send name
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:146
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActionController::API._renderers

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:128
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/set.rb:336</summary>

##### Set#each

```ruby
def each(&block)
  block or return enum_for(__method__) { size }
  @hash.each_key(&block)
  self
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:146
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:112</summary>

##### ActionController::Rendering#_process_options

```ruby
def _process_options(options)
  status, content_type, location = options.values_at(:status, :content_type, :location)

  self.status = status if status
  self.content_type = content_type if content_type
  headers["Location"] = url_for(location) if location

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:148
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:98</summary>

##### ActionController::Rendering#_process_options

```ruby
def _process_options(options)
  status, content_type, location = options.values_at(:status, :content_type, :location)

  self.status = status if status
  self.content_type = content_type if content_type
  headers["Location"] = url_for(location) if location

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:119
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:91</summary>

##### ActionController::Renderers._render_with_renderer_method_name

```ruby
def self._render_with_renderer_method_name(key)
  "_render_with_renderer_#{key}"
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:149
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:156</summary>

##### ActionController::Renderers#_render_with_renderer_json

```ruby
add :json do |json, options|
  json = json.to_json(options) unless json.kind_of?(String)

  if options[:callback].present?
    if content_type.nil? || content_type == Mime[:json]
      self.content_type = Mime[:js]
    end

    "/**/#{options[:callback]}(#{json})"
  else
    self.content_type ||= Mime[:json]
    json
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:150
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/json.rb:35</summary>

##### ActiveSupport::ToJsonWithActiveSupportEncoder#to_json

```ruby
def to_json(options = nil)
  if options.is_a?(::JSON::State)
    # Called from JSON.{generate,dump}, forward it to JSON gem's to_json
    super(options)
  else
    # to_json is being invoked directly, use ActiveSupport's encoder
    ActiveSupport::JSON.encode(self, options)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:157
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:21</summary>

##### ActiveSupport::JSON.encode

```ruby
def self.encode(value, options = nil)
  Encoding.json_encoder.new(options).encode(value)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/json.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:29</summary>

##### ActiveSupport::JSON::Encoding::JSONGemEncoder#initialize

```ruby
def initialize(options = nil)
  @options = options || {}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:34</summary>

##### ActiveSupport::JSON::Encoding::JSONGemEncoder#encode

```ruby
def encode(value)
  stringify jsonify value.as_json(options.dup)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:71</summary>

##### ActiveRecord::Delegation#as_json

```ruby
delegate :to_xml, :encode_with, :length, :each, :uniq, :join,
         :[], :&, :|, :+, :-, :sample, :reverse, :rotate, :compact, :in_groups, :in_groups_of,
         :to_sentence, :to_formatted_s, :as_json,
         :shuffle, :split, :slice, :index, :rindex, to: :records
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:199</summary>

##### ActiveRecord::Relation#records

```ruby
def records # :nodoc:
  load
  @records
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:421</summary>

##### ActiveRecord::Relation#load

```ruby
def load(&block)
  exec_queries(&block) unless loaded?

  self
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:546</summary>

##### ActiveRecord::Relation#exec_queries

```ruby
def exec_queries(&block)
  skip_query_cache_if_necessary do
    @records =
      if eager_loading?
        apply_join_dependency do |relation, join_dependency|
          if ActiveRecord::NullRelation === relation
            []
          else
            relation = join_dependency.apply_column_aliases(relation)
            rows = connection.select_all(relation.arel, "SQL")
            join_dependency.instantiate(rows, &block)
          end.freeze
        end
      else
        klass.find_by_sql(arel, &block).freeze
      end

    preload = preload_values
    preload += includes_values unless eager_loading?
    preloader = nil
    preload.each do |associations|
      preloader ||= build_preloader
      preloader.preload @records, associations
    end

    @records.each(&:readonly!) if readonly_value

    @loaded = true
    @records
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:422
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:578</summary>

##### ActiveRecord::Relation#skip_query_cache_if_necessary

```ruby
def skip_query_cache_if_necessary
  if skip_query_cache_value
    uncached do
      yield
    end
  else
    yield
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:547
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#skip_query_cache_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:579
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:472</summary>

##### ActiveRecord::Relation#eager_loading?

```ruby
def eager_loading?
  @should_eager_load ||=
    eager_load_values.any? ||
    includes_values.any? && (joined_includes_values.any? || references_eager_loaded_tables?)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:549
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#eager_load_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:474
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#includes_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:475
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:902</summary>

##### ActiveRecord::QueryMethods#arel

```ruby
def arel(aliases = nil) # :nodoc:
  @arel ||= build_arel(aliases)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:560
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:926</summary>

##### ActiveRecord::QueryMethods#build_arel

```ruby
def build_arel(aliases)
  arel = Arel::SelectManager.new(table)

  aliases = build_joins(arel, joins_values.flatten, aliases) unless joins_values.empty?
  build_left_outer_joins(arel, left_outer_joins_values.flatten, aliases) unless left_outer_joins_values.empty?

  arel.where(where_clause.ast) unless where_clause.empty?
  arel.having(having_clause.ast) unless having_clause.empty?
  if limit_value
    limit_attribute = ActiveModel::Attribute.with_cast_value(
      "LIMIT".freeze,
      connection.sanitize_limit(limit_value),
      Type.default_value,
    )
    arel.take(Arel::Nodes::BindParam.new(limit_attribute))
  end
  if offset_value
    offset_attribute = ActiveModel::Attribute.with_cast_value(
      "OFFSET".freeze,
      offset_value.to_i,
      Type.default_value,
    )
    arel.skip(Arel::Nodes::BindParam.new(offset_attribute))
  end
  arel.group(*arel_columns(group_values.uniq.reject(&:blank?))) unless group_values.empty?

  build_order(arel)

  build_select(arel)

  arel.distinct(distinct_value)
  arel.from(build_from) unless from_clause.empty?
  arel.lock(lock_value) if lock_value

  arel
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:903
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:10</summary>

##### Arel::SelectManager#initialize

```ruby
def initialize table = nil
  super()
  @ast   = Nodes::SelectStatement.new
  @ctx    = @ast.cores.last
  from table
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:927
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/tree_manager.rb:10</summary>

##### Arel::SelectManager#initialize

```ruby
def initialize table = nil
  super()
  @ast   = Nodes::SelectStatement.new
  @ctx    = @ast.cores.last
  from table
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:11
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/select_core.rb:8</summary>

##### Arel::Nodes::SelectCore#initialize

```ruby
def initialize
  super()
  @source         = JoinSource.new nil
  @top            = nil

  # http://savage.net.au/SQL/sql-92.bnf.html#set%20quantifier
  @set_quantifier = nil
  @projections    = []
  @wheres         = []
  @groups         = []
  @havings        = []
  @windows        = []
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/select_statement.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/join_source.rb:10</summary>

##### Arel::Nodes::JoinSource#initialize

```ruby
def initialize single_source, joinop = []
  super
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/select_core.rb:10
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/binary.rb:7</summary>

##### Arel::Nodes::JoinSource#initialize

```ruby
def initialize single_source, joinop = []
  super
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/join_source.rb:11
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/select_statement.rb:8</summary>

##### Arel::Nodes::SelectStatement#initialize

```ruby
def initialize cores = [SelectCore.new]
  super()
  @cores          = cores
  @orders         = []
  @limit          = nil
  @lock           = nil
  @offset         = nil
  @with           = nil
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:88</summary>

##### Arel::SelectManager#from

```ruby
def from table
  table = Nodes::SqlLiteral.new(table) if String === table

  case table
  when Nodes::Join
    @ctx.source.right << table
  else
    @ctx.source.left = table
  end

  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#joins_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:929
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#left_outer_joins_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:930
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#where_clause

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:932
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/where_clause.rb:6</summary>

##### ActiveRecord::Relation::WhereClause#empty?

```ruby
delegate :any?, :empty?, to: :predicates
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:932
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#having_clause

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:933
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/where_clause.rb:6</summary>

##### ActiveRecord::Relation::WhereClause#empty?

```ruby
delegate :any?, :empty?, to: :predicates
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:933
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#limit_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:934
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#offset_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:942
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#group_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:950
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1121</summary>

##### ActiveRecord::QueryMethods#build_order

```ruby
def build_order(arel)
  orders = order_values.uniq
  orders.reject!(&:blank?)

  arel.order(*orders) unless orders.empty?
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:952
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#order_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1122
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1042</summary>

##### ActiveRecord::QueryMethods#build_select

```ruby
def build_select(arel)
  if select_values.any?
    arel.project(*arel_columns(select_values.uniq))
  elsif klass.ignored_columns.any?
    arel.project(*klass.column_names.map { |field| arel_attribute(field) })
  else
    arel.project(table[Arel.star])
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:954
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#select_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1043
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:264</summary>

##### ActiveRecord::ModelSchema::ClassMethods.ignored_columns

```ruby
def ignored_columns
  if defined?(@ignored_columns)
    @ignored_columns
  else
    superclass.ignored_columns
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1045
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:264</summary>

##### ActiveRecord::ModelSchema::ClassMethods.ignored_columns

```ruby
def ignored_columns
  if defined?(@ignored_columns)
    @ignored_columns
  else
    superclass.ignored_columns
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:268
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:264</summary>

##### ActiveRecord::ModelSchema::ClassMethods.ignored_columns

```ruby
def ignored_columns
  if defined?(@ignored_columns)
    @ignored_columns
  else
    superclass.ignored_columns
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:268
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel.rb:33</summary>

##### Arel.star

```ruby
def self.star
  sql '*'
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1048
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel.rb:29</summary>

##### Arel.sql

```ruby
def self.sql raw_sql
  Arel::Nodes::SqlLiteral.new raw_sql
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel.rb:34
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/table.rb:80</summary>

##### Arel::Table#[]

```ruby
def [] name
  ::Arel::Attribute.new self, name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1048
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:133</summary>

##### Arel::SelectManager#project

```ruby
def project *projections
  # FIXME: converting these to SQLLiterals is probably not good, but
  # rails tests require it.
  @ctx.projections.concat projections.map { |x|
    STRING_OR_SYMBOL_CLASS.include?(x.class) ? Nodes::SqlLiteral.new(x.to_s) : x
  }
  self
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:1048
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#distinct_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:956
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:150</summary>

##### Arel::SelectManager#distinct

```ruby
def distinct(value = true)
  if value
    @ctx.set_quantifier = Arel::Nodes::Distinct.new
  else
    @ctx.set_quantifier = nil
  end
  self
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:956
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#from_clause

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:957
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/from_clause.rb:17</summary>

##### ActiveRecord::Relation::FromClause#empty?

```ruby
def empty?
  value.nil?
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:957
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#lock_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:958
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:40</summary>

##### ActiveRecord::Querying.find_by_sql

```ruby
def find_by_sql(sql, binds = [], preparable: nil, &block)
  result_set = connection.select_all(sanitize_sql(sql), "#{name} Load", binds, preparable: preparable)
  column_types = result_set.column_types.dup
  attribute_types.each_key { |k| column_types.delete k }
  message_bus = ActiveSupport::Notifications.instrumenter

  payload = {
    record_count: result_set.length,
    class_name: name
  }

  message_bus.instrument("instantiation.active_record", payload) do
    result_set.map { |record| instantiate(record, column_types, &block) }
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:560
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:89</summary>

##### ActiveRecord::ConnectionHandling.connection

```ruby
def connection
  retrieve_connection
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:117</summary>

##### ActiveRecord::ConnectionHandling.retrieve_connection

```ruby
def retrieve_connection
  connection_handler.retrieve_connection(connection_specification_name)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:90
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:130</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:98
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:98
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1011</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection

```ruby
def retrieve_connection(spec_name) #:nodoc:
  pool = retrieve_connection_pool(spec_name)
  raise ConnectionNotEstablished, "No connection pool with '#{spec_name}' found." unless pool
  pool.connection
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:118
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1039</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection_pool

```ruby
def retrieve_connection_pool(spec_name)
  owner_to_pool.fetch(spec_name) do
    # Check if a connection was previously established in an ancestor process,
    # which may have been forked.
    if ancestor_pool = pool_from_any_process_for(spec_name)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection(ancestor_pool.spec.to_hash).tap do |pool|
        pool.schema_cache = ancestor_pool.schema_cache if ancestor_pool.schema_cache
      end
    else
      owner_to_pool[spec_name] = nil
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1012
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:168</summary>

##### Concurrent::Map#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:108</summary>

##### Concurrent::Collection::NonConcurrentMapBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:169
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:381</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connection

```ruby
def connection
  @thread_cached_conns[connection_cache_key(@lock_thread || Thread.current)] ||= checkout
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1014
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:667</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connection_cache_key

```ruby
def connection_cache_key(thread)
  thread
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:382
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:382
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/sanitization.rb:22</summary>

##### ActiveRecord::Sanitization::ClassMethods.sanitize_sql_for_conditions

```ruby
def sanitize_sql_for_conditions(condition)
  return nil if condition.blank?

  case condition
  when Array; sanitize_sql_array(condition)
  else        condition
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:19</summary>

##### Object#blank?

```ruby
def blank?
  respond_to?(:empty?) ? !!empty? : !self
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/sanitization.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:95</summary>

##### ActiveRecord::ConnectionAdapters::QueryCache#select_all

```ruby
def select_all(arel, name = nil, binds = [], preparable: nil)
  if @query_cache_enabled && !locked?(arel)
    arel = arel_from_relation(arel)
    sql, binds = to_sql_and_binds(arel, binds)

    if preparable.nil?
      preparable = prepared_statements ? visitor.preparable : false
    end

    cache_sql(sql, name, binds) { super(sql, name, binds, preparable: preparable) }
  else
    super
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:135</summary>

##### ActiveRecord::ConnectionAdapters::QueryCache#locked?

```ruby
def locked?(arel)
  arel = arel.arel if arel.is_a?(Relation)
  arel.respond_to?(:locked) && arel.locked
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/select_manager.rb:68</summary>

##### Arel::SelectManager#locked

```ruby
def locked
  @ast.lock
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:137
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:498</summary>

##### ActiveRecord::ConnectionAdapters::DatabaseStatements#arel_from_relation

```ruby
def arel_from_relation(relation)
  if relation.is_a?(Relation)
    relation.arel
  else
    relation
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:97
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:17</summary>

##### ActiveRecord::ConnectionAdapters::DatabaseStatements#to_sql_and_binds

```ruby
def to_sql_and_binds(arel_or_sql_string, binds = []) # :nodoc:
  if arel_or_sql_string.respond_to?(:ast)
    unless binds.empty?
      raise "Passing bind parameters with an arel AST is forbidden. " \
        "The values must be stored on the AST directly"
    end

    if prepared_statements
      sql, binds = visitor.accept(arel_or_sql_string.ast, collector).value

      if binds.length > bind_params_length
        unprepared_statement do
          sql, binds = to_sql_and_binds(arel_or_sql_string)
          visitor.preparable = false
        end
      end
    else
      sql = visitor.accept(arel_or_sql_string.ast, collector).value
    end
    [sql.freeze, binds]
  else
    visitor.preparable = false if prepared_statements
    [arel_or_sql_string.dup.freeze, binds]
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:98
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:609</summary>

##### ActiveRecord::ConnectionAdapters::AbstractAdapter#collector

```ruby
def collector
  if prepared_statements
    Arel::Collectors::Composite.new(
      Arel::Collectors::SQLString.new,
      Arel::Collectors::Bind.new,
    )
  else
    Arel::Collectors::SubstituteBinds.new(
      self,
      Arel::Collectors::SQLString.new,
    )
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/sql_string.rb:8</summary>

##### Arel::Collectors::SQLString#initialize

```ruby
def initialize(*)
  super
  @bind_index = 1
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:612
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:5</summary>

##### Arel::Collectors::SQLString#initialize

```ruby
def initialize(*)
  super
  @bind_index = 1
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/sql_string.rb:9
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:6</summary>

##### Arel::Collectors::Bind#initialize

```ruby
def initialize
  @binds = []
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:6</summary>

##### Arel::Collectors::Composite#initialize

```ruby
def initialize(left, right)
  @left = left
  @right = right
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract_adapter.rb:611
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/determine_if_preparable_visitor.rb:8</summary>

##### ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor#accept

```ruby
def accept(*)
  @preparable = true
  super
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:7</summary>

##### ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor#accept

```ruby
def accept(*)
  @preparable = true
  super
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/determine_if_preparable_visitor.rb:10
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:13</summary>

##### Arel::Visitors::Reduce#visit

```ruby
def visit object, collector
  dispatch_method = dispatch[object.class]
  send dispatch_method, object, collector
rescue NoMethodError => e
  raise e if respond_to?(dispatch_method, true)
  superklass = object.class.ancestors.find { |klass|
    respond_to?(dispatch[klass], true)
  }
  raise(TypeError, "Cannot visit #{object.class}") unless superklass
  dispatch[object.class] = dispatch[superklass]
  retry
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/visitor.rb:25</summary>

##### Arel::Visitors::Visitor#dispatch

```ruby
def dispatch
  @dispatch
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/sqlite.rb:12</summary>

##### Arel::Visitors::SQLite#visit_Arel_Nodes_SelectStatement

```ruby
def visit_Arel_Nodes_SelectStatement o, collector
  o.limit = Arel::Nodes::Limit.new(-1) if o.offset && !o.limit
  super
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:210</summary>

##### Arel::Visitors::SQLite#visit_Arel_Nodes_SelectStatement

```ruby
def visit_Arel_Nodes_SelectStatement o, collector
  o.limit = Arel::Nodes::Limit.new(-1) if o.offset && !o.limit
  super
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/sqlite.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:240</summary>

##### Arel::Visitors::ToSql#visit_Arel_Nodes_SelectCore

```ruby
def visit_Arel_Nodes_SelectCore o, collector
  collector << "SELECT"

  collector = maybe_visit o.top, collector

  collector = maybe_visit o.set_quantifier, collector

  collect_nodes_for o.projections, collector, SPACE

  if o.source && !o.source.empty?
    collector << " FROM "
    collector = visit o.source, collector
  end

  collect_nodes_for o.wheres, collector, WHERE, AND
  collect_nodes_for o.groups, collector, GROUP_BY
  unless o.havings.empty?
    collector << " HAVING "
    inject_join o.havings, collector, AND
  end
  collect_nodes_for o.windows, collector, WINDOW

  collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:217
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:11</summary>

##### Arel::Collectors::Composite#<<

```ruby
def << str
  left << str
  right << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:241
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:13</summary>

##### Arel::Collectors::PlainString#<<

```ruby
def << str
  @str << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:10</summary>

##### Arel::Collectors::Bind#<<

```ruby
def << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:812</summary>

##### Arel::Visitors::ToSql#maybe_visit

```ruby
def maybe_visit thing, collector
  return collector unless thing
  collector << " "
  visit thing, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:243
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:812</summary>

##### Arel::Visitors::ToSql#maybe_visit

```ruby
def maybe_visit thing, collector
  return collector unless thing
  collector << " "
  visit thing, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:245
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:265</summary>

##### Arel::Visitors::ToSql#collect_nodes_for

```ruby
def collect_nodes_for nodes, collector, spacer, connector = COMMA
  unless nodes.empty?
    collector << spacer
    len = nodes.length - 1
    nodes.each_with_index do |x, i|
      collector = visit(x, collector)
      collector << connector unless len == i
    end
  end
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:247
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:11</summary>

##### Arel::Collectors::Composite#<<

```ruby
def << str
  left << str
  right << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:267
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:13</summary>

##### Arel::Collectors::PlainString#<<

```ruby
def << str
  @str << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:10</summary>

##### Arel::Collectors::Bind#<<

```ruby
def << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:13</summary>

##### Arel::Visitors::Reduce#visit

```ruby
def visit object, collector
  dispatch_method = dispatch[object.class]
  send dispatch_method, object, collector
rescue NoMethodError => e
  raise e if respond_to?(dispatch_method, true)
  superklass = object.class.ancestors.find { |klass|
    respond_to?(dispatch[klass], true)
  }
  raise(TypeError, "Cannot visit #{object.class}") unless superklass
  dispatch[object.class] = dispatch[superklass]
  retry
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:270
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/visitor.rb:25</summary>

##### Arel::Visitors::Visitor#dispatch

```ruby
def dispatch
  @dispatch
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:727</summary>

##### Arel::Visitors::ToSql#visit_Arel_Attributes_Attribute

```ruby
def visit_Arel_Attributes_Attribute o, collector
  join_name = o.relation.table_alias || o.relation.name
  collector << "#{quote_table_name join_name}.#{quote_column_name o.name}"
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:802</summary>

##### Arel::Visitors::ToSql#quote_table_name

```ruby
def quote_table_name name
  return name if Arel::Nodes::SqlLiteral === name
  @connection.quote_table_name(name)
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:729
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/sqlite3/quoting.rb:15</summary>

##### ActiveRecord::ConnectionAdapters::SQLite3::Quoting#quote_table_name

```ruby
def quote_table_name(name)
  @quoted_table_names[name] ||= super.gsub(".", "\".\"").freeze
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:804
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:807</summary>

##### Arel::Visitors::ToSql#quote_column_name

```ruby
def quote_column_name name
  return name if Arel::Nodes::SqlLiteral === name
  @connection.quote_column_name(name)
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:729
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:11</summary>

##### Arel::Collectors::Composite#<<

```ruby
def << str
  left << str
  right << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:729
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:13</summary>

##### Arel::Collectors::PlainString#<<

```ruby
def << str
  @str << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:10</summary>

##### Arel::Collectors::Bind#<<

```ruby
def << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/nodes/join_source.rb:14</summary>

##### Arel::Nodes::JoinSource#empty?

```ruby
def empty?
  !left && right.empty?
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:249
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:11</summary>

##### Arel::Collectors::Composite#<<

```ruby
def << str
  left << str
  right << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:250
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:13</summary>

##### Arel::Collectors::PlainString#<<

```ruby
def << str
  @str << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:10</summary>

##### Arel::Collectors::Bind#<<

```ruby
def << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:13</summary>

##### Arel::Visitors::Reduce#visit

```ruby
def visit object, collector
  dispatch_method = dispatch[object.class]
  send dispatch_method, object, collector
rescue NoMethodError => e
  raise e if respond_to?(dispatch_method, true)
  superklass = object.class.ancestors.find { |klass|
    respond_to?(dispatch[klass], true)
  }
  raise(TypeError, "Cannot visit #{object.class}") unless superklass
  dispatch[object.class] = dispatch[superklass]
  retry
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:251
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/visitor.rb:25</summary>

##### Arel::Visitors::Visitor#dispatch

```ruby
def dispatch
  @dispatch
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:544</summary>

##### Arel::Visitors::ToSql#visit_Arel_Nodes_JoinSource

```ruby
def visit_Arel_Nodes_JoinSource o, collector
  if o.left
    collector = visit o.left, collector
  end
  if o.right.any?
    collector << SPACE if o.left
    collector = inject_join o.right, collector, SPACE
  end
  collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:13</summary>

##### Arel::Visitors::Reduce#visit

```ruby
def visit object, collector
  dispatch_method = dispatch[object.class]
  send dispatch_method, object, collector
rescue NoMethodError => e
  raise e if respond_to?(dispatch_method, true)
  superklass = object.class.ancestors.find { |klass|
    respond_to?(dispatch[klass], true)
  }
  raise(TypeError, "Cannot visit #{object.class}") unless superklass
  dispatch[object.class] = dispatch[superklass]
  retry
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:546
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/visitor.rb:25</summary>

##### Arel::Visitors::Visitor#dispatch

```ruby
def dispatch
  @dispatch
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:609</summary>

##### Arel::Visitors::ToSql#visit_Arel_Table

```ruby
def visit_Arel_Table o, collector
  if o.table_alias
    collector << "#{quote_table_name o.name} #{quote_table_name o.table_alias}"
  else
    collector << quote_table_name(o.name)
  end
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/reduce.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:802</summary>

##### Arel::Visitors::ToSql#quote_table_name

```ruby
def quote_table_name name
  return name if Arel::Nodes::SqlLiteral === name
  @connection.quote_table_name(name)
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/sqlite3/quoting.rb:15</summary>

##### ActiveRecord::ConnectionAdapters::SQLite3::Quoting#quote_table_name

```ruby
def quote_table_name(name)
  @quoted_table_names[name] ||= super.gsub(".", "\".\"").freeze
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:804
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:11</summary>

##### Arel::Collectors::Composite#<<

```ruby
def << str
  left << str
  right << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:613
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:13</summary>

##### Arel::Collectors::PlainString#<<

```ruby
def << str
  @str << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:10</summary>

##### Arel::Collectors::Bind#<<

```ruby
def << str
  self
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:265</summary>

##### Arel::Visitors::ToSql#collect_nodes_for

```ruby
def collect_nodes_for nodes, collector, spacer, connector = COMMA
  unless nodes.empty?
    collector << spacer
    len = nodes.length - 1
    nodes.each_with_index do |x, i|
      collector = visit(x, collector)
      collector << connector unless len == i
    end
  end
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:254
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:265</summary>

##### Arel::Visitors::ToSql#collect_nodes_for

```ruby
def collect_nodes_for nodes, collector, spacer, connector = COMMA
  unless nodes.empty?
    collector << spacer
    len = nodes.length - 1
    nodes.each_with_index do |x, i|
      collector = visit(x, collector)
      collector << connector unless len == i
    end
  end
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:255
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:265</summary>

##### Arel::Visitors::ToSql#collect_nodes_for

```ruby
def collect_nodes_for nodes, collector, spacer, connector = COMMA
  unless nodes.empty?
    collector << spacer
    len = nodes.length - 1
    nodes.each_with_index do |x, i|
      collector = visit(x, collector)
      collector << connector unless len == i
    end
  end
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:260
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:234</summary>

##### Arel::Visitors::ToSql#visit_Arel_Nodes_SelectOptions

```ruby
def visit_Arel_Nodes_SelectOptions o, collector
  collector = maybe_visit o.limit, collector
  collector = maybe_visit o.offset, collector
  collector = maybe_visit o.lock, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:229
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:812</summary>

##### Arel::Visitors::ToSql#maybe_visit

```ruby
def maybe_visit thing, collector
  return collector unless thing
  collector << " "
  visit thing, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:235
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:812</summary>

##### Arel::Visitors::ToSql#maybe_visit

```ruby
def maybe_visit thing, collector
  return collector unless thing
  collector << " "
  visit thing, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:236
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:812</summary>

##### Arel::Visitors::ToSql#maybe_visit

```ruby
def maybe_visit thing, collector
  return collector unless thing
  collector << " "
  visit thing, collector
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/visitors/to_sql.rb:237
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:23</summary>

##### Arel::Collectors::Composite#value

```ruby
def value
  [left.value, right.value]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/plain_string.rb:9</summary>

##### Arel::Collectors::PlainString#value

```ruby
def value
  @str
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:24
```
</details>
<details open>
<summary>vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/bind.rb:19</summary>

##### Arel::Collectors::Bind#value

```ruby
def value
  @binds
end
# called from vendor/bundle/gems/arel-9.0.0/lib/arel/collectors/composite.rb:24
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_limits.rb:67</summary>

##### ActiveRecord::ConnectionAdapters::DatabaseLimits#bind_params_length

```ruby
def bind_params_length
  65535
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/database_statements.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:112</summary>

##### ActiveRecord::ConnectionAdapters::QueryCache#cache_sql

```ruby
def cache_sql(sql, name, binds)
  @lock.synchronize do
    result =
      if @query_cache[sql].key?(binds)
        ActiveSupport::Notifications.instrument(
          "sql.active_record",
          sql: sql,
          binds: binds,
          type_casted_binds: -> { type_casted_binds(binds) },
          name: name,
          connection_id: object_id,
          cached: true,
        )
        @query_cache[sql][binds]
      else
        @query_cache[sql][binds] = yield
      end
    result.dup
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:104
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/concurrency/load_interlock_aware_monitor.rb:11</summary>

##### ActiveSupport::Concurrency::LoadInterlockAwareMonitor#mon_enter

```ruby
def mon_enter
  mon_try_enter ||
    ActiveSupport::Dependencies.interlock.permit_concurrent_loads { super }
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:170</summary>

##### MonitorMixin#mon_try_enter

```ruby
def mon_try_enter
  if @mon_owner != Thread.current
    unless @mon_mutex.try_lock
      return false
    end
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
  return true
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/concurrency/load_interlock_aware_monitor.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:166</summary>

##### ActiveSupport::Notifications.instrument

```ruby
def instrument(name, payload = {})
  if notifier.listening?(name)
    instrumenter.instrument(name, payload) { yield payload if block_given? }
  else
    yield payload if block_given?
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:116
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:63</summary>

##### ActiveSupport::Notifications::Fanout#listening?

```ruby
def listening?(name)
  listeners_for(name).any?
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:167
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:64
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:19</summary>

##### ActiveSupport::Notifications::Instrumenter#instrument

```ruby
def instrument(name, payload = {})
  # some of the listeners might have state
  listeners_state = start name, payload
  begin
    yield payload
  rescue Exception => e
    payload[:exception] = [e.class.name, e.message]
    payload[:exception_object] = e
    raise e
  ensure
    finish_with_state listeners_state, name, payload
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:168
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:99</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#start

```ruby
def start(name, id, payload)
  @delegate.start name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:79</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:90</summary>

##### ActiveRecord::LogSubscriber#logger

```ruby
def logger
  ActiveRecord::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.logger

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:86</summary>

##### ActiveSupport::LogSubscriber#start

```ruby
def start(name, id, payload)
  super if logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:80
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:58</summary>

##### ActiveSupport::Notifications::Event#initialize

```ruby
def initialize(name, start, ending, transaction_id, payload)
  @name           = name
  @payload        = payload.dup
  @time           = start
  @transaction_id = transaction_id
  @end            = ending
  @children       = []
  @duration       = nil
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:87
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:99</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#start

```ruby
def start(name, id, payload)
  @delegate.start name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/explain_subscriber.rb:8</summary>

##### ActiveRecord::ExplainSubscriber#start

```ruby
def start(name, id, payload)
  # unused
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:100
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:43</summary>

##### ActiveSupport::Notifications::Instrumenter#finish_with_state

```ruby
def finish_with_state(listeners_state, name, payload)
  @notifier.finish name, @id, payload, listeners_state
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:47</summary>

##### ActiveSupport::Notifications::Fanout#finish

```ruby
def finish(name, id, payload, listeners = listeners_for(name))
  listeners.each { |s| s.finish(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:103</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#finish

```ruby
def finish(name, id, payload)
  @delegate.finish name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:48
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:83</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:104
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:90</summary>

##### ActiveRecord::LogSubscriber#logger

```ruby
def logger
  ActiveRecord::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.logger

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:94</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:20</summary>

##### ActiveRecord::LogSubscriber#sql

```ruby
def sql(event)
  self.class.runtime += event.duration
  return unless logger.debug?

  payload = event.payload

  return if IGNORE_PAYLOAD_NAMES.include?(payload[:name])

  name  = "#{payload[:name]} (#{event.duration.round(1)}ms)"
  name  = "CACHE #{name}" if payload[:cached]
  sql   = payload[:sql]
  binds = nil

  unless (payload[:binds] || []).empty?
    casted_params = type_casted_binds(payload[:type_casted_binds])
    binds = "  " + payload[:binds].zip(casted_params).map { |attr, value|
      render_bind(attr, value)
    }.inspect
  end

  name = colorize_payload_name(name, payload[:name])
  sql  = color(sql, sql_color(sql), true)

  debug "  #{name}  #{sql}#{binds}"
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:11</summary>

##### ActiveRecord::LogSubscriber.runtime

```ruby
def self.runtime
  ActiveRecord::RuntimeRegistry.sql_runtime ||= 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:80</summary>

##### ActiveSupport::Notifications::Event#duration

```ruby
def duration
  @duration ||= 1000.0 * (self.end - time)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:7</summary>

##### ActiveRecord::LogSubscriber.runtime=

```ruby
def self.runtime=(value)
  ActiveRecord::RuntimeRegistry.sql_runtime = value
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime=

```ruby
class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:90</summary>

##### ActiveRecord::LogSubscriber#logger

```ruby
def logger
  ActiveRecord::Base.logger
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.logger

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:94</summary>

##### ActiveSupport::Logger#debug?

```ruby
def #{severity.downcase}?                # def debug?
  Logger::#{severity} >= level           #   DEBUG >= level
end                                      # end
      EOT
    end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:80</summary>

##### ActiveSupport::Notifications::Event#duration

```ruby
def duration
  @duration ||= 1000.0 * (self.end - time)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/numeric/conversions.rb:104</summary>

##### ActiveSupport::NumericWithFormat#to_s

```ruby
def to_s(format = nil, options = nil)
  case format
  when nil
    super()
  when Integer, String
    super(format)
  when :phone
    ActiveSupport::NumberHelper.number_to_phone(self, options || {})
  when :currency
    ActiveSupport::NumberHelper.number_to_currency(self, options || {})
  when :percentage
    ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
  when :delimited
    ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
  when :rounded
    ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
  when :human
    ActiveSupport::NumberHelper.number_to_human(self, options || {})
  when :human_size
    ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
  when Symbol
    super()
  else
    super(format)
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:61</summary>

##### ActiveRecord::LogSubscriber#colorize_payload_name

```ruby
def colorize_payload_name(name, payload_name)
  if payload_name.blank? || payload_name == "SQL" # SQL vs Model Load/Exists
    color(name, MAGENTA, true)
  else
    color(name, CYAN, true)
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:40
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:122</summary>

##### String#blank?

```ruby
def blank?
  # The regexp that matches blank strings is expensive. For the case of empty
  # strings we can speed up this method (~3.5x) with an empty? call. The
  # penalty for the rest of strings is marginal.
  empty? ||
    begin
      BLANK_RE.match?(self)
    rescue Encoding::CompatibilityError
      ENCODED_BLANKS[self.encoding].match?(self)
    end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:62
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:105</summary>

##### ActiveSupport::LogSubscriber#color

```ruby
def color(text, color, bold = false) # :doc:
  return text unless colorize_logging
  color = self.class.const_get(color.upcase) if color.is_a?(Symbol)
  bold  = bold ? BOLD : ""
  "#{bold}#{color}#{text}#{CLEAR}"
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:65
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:67</summary>

##### ActiveSupport::LogSubscriber#colorize_logging

```ruby
def #{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:106
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:69</summary>

##### ActiveRecord::LogSubscriber#sql_color

```ruby
def sql_color(sql)
  case sql
  when /\A\s*rollback/mi
    RED
  when /select .*for update/mi, /\A\s*lock/mi
    WHITE
  when /\A\s*select/i
    BLUE
  when /\A\s*insert/i
    GREEN
  when /\A\s*update/i
    YELLOW
  when /\A\s*delete/i
    RED
  when /transaction\s*\Z/i
    CYAN
  else
    MAGENTA
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:105</summary>

##### ActiveSupport::LogSubscriber#color

```ruby
def color(text, color, bold = false) # :doc:
  return text unless colorize_logging
  color = self.class.const_get(color.upcase) if color.is_a?(Symbol)
  bold  = bold ? BOLD : ""
  "#{bold}#{color}#{text}#{CLEAR}"
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:67</summary>

##### ActiveSupport::LogSubscriber#colorize_logging

```ruby
def #{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:106
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:94</summary>

##### ActiveRecord::LogSubscriber#debug

```ruby
def debug(progname = nil, &block)
  return unless super

  if ActiveRecord::Base.verbose_query_logs
    log_query_source
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:95</summary>

##### ActiveRecord::LogSubscriber#debug

```ruby
def debug(progname = nil, &block)
  return unless super

  if ActiveRecord::Base.verbose_query_logs
    log_query_source
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:90</summary>

##### ActiveRecord::LogSubscriber#logger

```ruby
def logger
  ActiveRecord::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.logger

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:91
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:90</summary>

##### ActiveRecord::LogSubscriber#logger

```ruby
def logger
  ActiveRecord::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.logger

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:91
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:490</summary>

##### Logger#debug

```ruby
def debug(progname = nil, &block)
  add(DEBUG, nil, progname, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:26</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:491
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::Logger::SimpleFormatter#call

```ruby
def call(severity, timestamp, progname, msg)
  "#{String === msg ? msg : msg.inspect}\n"
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:22</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:53</summary>

##### ActiveSupport::TaggedLogging::Formatter#tags_text

```ruby
def tags_text
  tags = current_tags
  if tags.any?
    tags.collect { |tag| "[#{tag}] " }.join
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveRecord::Base.verbose_query_logs

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:97
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:103</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#finish

```ruby
def finish(name, id, payload)
  @delegate.finish name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:48
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/explain_subscriber.rb:12</summary>

##### ActiveRecord::ExplainSubscriber#finish

```ruby
def finish(name, id, payload)
  if ExplainRegistry.collect? && !ignore_payload?(payload)
    ExplainRegistry.queries << payload.values_at(:sql, :binds)
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:104
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55</summary>

##### ActiveRecord::ExplainRegistry.collect?

```ruby
singleton_class.delegate name, to: :instance
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/explain_subscriber.rb:13
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/explain_registry.rb:23</summary>

##### ActiveRecord::ExplainRegistry#collect?

```ruby
def collect?
  @collect
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/result.rb:108</summary>

##### ActiveRecord::Result#initialize_copy

```ruby
def initialize_copy(other)
  @columns      = columns.dup
  @rows         = rows.dup
  @column_types = column_types.dup
  @hash_rows    = nil
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/query_cache.rb:129
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:345</summary>

##### ActiveRecord::ModelSchema::ClassMethods.attribute_types

```ruby
def attribute_types # :nodoc:
  load_schema
  @attribute_types ||= Hash.new(Type.default_value)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:454</summary>

##### ActiveRecord::ModelSchema::ClassMethods.load_schema

```ruby
def load_schema
  return if schema_loaded?
  @load_schema_monitor.synchronize do
    return if defined?(@columns_hash) && @columns_hash

    load_schema!

    @schema_loaded = true
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:346
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:450</summary>

##### ActiveRecord::ModelSchema::ClassMethods.schema_loaded?

```ruby
def schema_loaded?
  defined?(@schema_loaded) && @schema_loaded
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/model_schema.rb:455
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:189</summary>

##### ActiveSupport::Notifications.instrumenter

```ruby
def instrumenter
  InstrumentationRegistry.instance.instrumenter_for(notifier)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:209</summary>

##### ActiveSupport::Notifications::InstrumentationRegistry#instrumenter_for

```ruby
def instrumenter_for(notifier)
  @registry[notifier] ||= Instrumenter.new(notifier)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications.rb:190
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/result.rb:47</summary>

##### ActiveRecord::Result#length

```ruby
def length
  @rows.length
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:47
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:19</summary>

##### ActiveSupport::Notifications::Instrumenter#instrument

```ruby
def instrument(name, payload = {})
  # some of the listeners might have state
  listeners_state = start name, payload
  begin
    yield payload
  rescue Exception => e
    payload[:exception] = [e.class.name, e.message]
    payload[:exception_object] = e
    raise e
  ensure
    finish_with_state listeners_state, name, payload
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:51
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:34</summary>

##### ActiveSupport::Notifications::Instrumenter#start

```ruby
def start(name, payload)
  @notifier.start name, @id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:43</summary>

##### ActiveSupport::Notifications::Fanout#start

```ruby
def start(name, id, payload)
  listeners_for(name).each { |s| s.start(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:55</summary>

##### ActiveSupport::Notifications::Fanout#listeners_for

```ruby
def listeners_for(name)
  # this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)
  @listeners_for[name] || synchronize do
    # use synchronisation when accessing @subscribers
    @listeners_for[name] ||= @subscribers.select { |s| s.subscribed_to?(name) }
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/result.rb:55</summary>

##### ActiveRecord::Result#each

```ruby
def each
  if block_given?
    hash_rows.each { |row| yield row }
  else
    hash_rows.to_enum { @rows.size }
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/querying.rb:52
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/result.rb:123</summary>

##### ActiveRecord::Result#hash_rows

```ruby
def hash_rows
  @hash_rows ||=
    begin
      # We freeze the strings to prevent them getting duped when
      # used as keys in ActiveRecord::Base's @attributes hash
      columns = @columns.map { |c| c.dup.freeze }
      @rows.map { |row|
        # In the past we used Hash[columns.zip(row)]
        #  though elegant, the verbose way is much more efficient
        #  both time and memory wise cause it avoids a big array allocation
        #  this method is called a lot and needs to be micro optimised
        hash = {}

        index = 0
        length = columns.length

        while index < length
          hash[columns[index]] = row[index]
          index += 1
        end

        hash
      }
    end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/result.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:43</summary>

##### ActiveSupport::Notifications::Instrumenter#finish_with_state

```ruby
def finish_with_state(listeners_state, name, payload)
  @notifier.finish name, @id, payload, listeners_state
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:47</summary>

##### ActiveSupport::Notifications::Fanout#finish

```ruby
def finish(name, id, payload, listeners = listeners_for(name))
  listeners.each { |s| s.finish(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#preload_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:563
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:472</summary>

##### ActiveRecord::Relation#eager_loading?

```ruby
def eager_loading?
  @should_eager_load ||=
    eager_load_values.any? ||
    includes_values.any? && (joined_includes_values.any? || references_eager_loaded_tables?)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:564
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#eager_load_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:474
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#includes_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:475
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#includes_values

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:564
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:69</summary>

##### ActiveRecord::QueryMethods#readonly_value

```ruby
def #{method_name}                   # def includes_values
  get_value(#{name.inspect})         #   get_value(:includes)
end                                  # end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation.rb:571
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:907</summary>

##### ActiveRecord::QueryMethods#get_value

```ruby
def get_value(name) # :nodoc:
  @values.fetch(name, DEFAULT_VALUES[name])
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/query_methods.rb:70
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/json.rb:151</summary>

##### Array#as_json

```ruby
def as_json(options = nil) #:nodoc:
  map { |v| options ? v.as_json(options.dup) : v.as_json }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/relation/delegation.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:85</summary>

##### ActiveSupport::JSON::Encoding::JSONGemEncoder#jsonify

```ruby
def jsonify(value)
  case value
  when String
    EscapedString.new(value)
  when Numeric, NilClass, TrueClass, FalseClass
    value.as_json
  when Hash
    Hash[value.map { |k, v| [jsonify(k), jsonify(v)] }]
  when Array
    value.map { |v| jsonify(v) }
  else
    jsonify value.as_json
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:35
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:101</summary>

##### ActiveSupport::JSON::Encoding::JSONGemEncoder#stringify

```ruby
def stringify(jsonified)
  ::JSON.generate(jsonified, quirks_mode: true, max_nesting: false)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:35
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/json/common.rb:208</summary>

##### JSON.generate

```ruby
def generate(obj, opts = nil)
  if State === opts
    state, opts = opts, nil
  else
    state = SAFE_STATE_PROTOTYPE.dup
  end
  if opts
    if opts.respond_to? :to_hash
      opts = opts.to_hash
    elsif opts.respond_to? :to_h
      opts = opts.to_h
    else
      raise TypeError, "can't convert #{opts.class} into Hash"
    end
    state = state.configure(opts)
  end
  state.generate(obj)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/json/encoding.rb:102
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:26</summary>

##### Object#present?

```ruby
def present?
  !blank?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:159
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:57</summary>

##### NilClass#blank?

```ruby
def blank?
  true
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/object/blank.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:150</summary>

##### ActionController::Metal#content_type

```ruby
delegate :headers, :status=, :location=, :content_type=,
         :status, :location, :content_type, to: "@_response"
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:166
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:247</summary>

##### ActionDispatch::Response#content_type

```ruby
def content_type
  parsed_content_type_header.mime_type
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:150
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:422</summary>

##### ActionDispatch::Response#parsed_content_type_header

```ruby
def parsed_content_type_header
  parse_content_type(get_header(CONTENT_TYPE))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:248
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:412</summary>

##### ActionDispatch::Response#parse_content_type

```ruby
def parse_content_type(content_type)
  if content_type && match = CONTENT_TYPE_PARSER.match(content_type)
    ContentTypeHeader.new(match[:type], match[:charset])
  else
    NullContentTypeHeader
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:40</summary>

##### Mime.[]

```ruby
def [](type)
  return type if type.is_a?(Type)
  Type.lookup_by_extension(type)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:166
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:148</summary>

##### Mime::Type.lookup_by_extension

```ruby
def lookup_by_extension(extension)
  EXTENSION_LOOKUP[extension.to_s]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:150</summary>

##### ActionController::Metal#content_type=

```ruby
delegate :headers, :status=, :location=, :content_type=,
         :status, :location, :content_type, to: "@_response"
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/renderers.rb:166
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:229</summary>

##### ActionDispatch::Response#content_type=

```ruby
def content_type=(content_type)
  return unless content_type
  new_header_info = parse_content_type(content_type.to_s)
  prev_header_info = parsed_content_type_header
  charset = new_header_info.charset || prev_header_info.charset
  charset ||= self.class.default_charset unless prev_header_info.mime_type
  set_content_type new_header_info.mime_type, charset
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:150
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:232</summary>

##### Mime::Type#to_s

```ruby
def to_s
  @string
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:231
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:412</summary>

##### ActionDispatch::Response#parse_content_type

```ruby
def parse_content_type(content_type)
  if content_type && match = CONTENT_TYPE_PARSER.match(content_type)
    ContentTypeHeader.new(match[:type], match[:charset])
  else
    NullContentTypeHeader
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:231
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:422</summary>

##### ActionDispatch::Response#parsed_content_type_header

```ruby
def parsed_content_type_header
  parse_content_type(get_header(CONTENT_TYPE))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:232
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:412</summary>

##### ActionDispatch::Response#parse_content_type

```ruby
def parse_content_type(content_type)
  if content_type && match = CONTENT_TYPE_PARSER.match(content_type)
    ContentTypeHeader.new(match[:type], match[:charset])
  else
    NullContentTypeHeader
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActionDispatch::Response.default_charset

```ruby
def self.#{sym}
  @@#{sym}
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:234
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:426</summary>

##### ActionDispatch::Response#set_content_type

```ruby
def set_content_type(content_type, charset)
  type = (content_type || "").dup
  type << "; charset=#{charset.to_s.downcase}" if charset
  set_header CONTENT_TYPE, type
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:235
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:183</summary>

##### ActionDispatch::Response#set_header

```ruby
def set_header(key, v); headers[key] = v;   end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:429
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:44</summary>

##### ActionDispatch::Response::Header#[]=

```ruby
def []=(k, v)
  if @response.sending? || @response.sent?
    raise ActionDispatch::IllegalStateError, "header already sent"
  end

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:183
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:219</summary>

##### ActionDispatch::Response#sending?

```ruby
def sending?;   synchronize { @sending };   end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:45
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:219
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:221</summary>

##### ActionDispatch::Response#sent?

```ruby
def sent?;      synchronize { @sent };      end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:45
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:221
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### ActionDispatch::Response::Header#[]=

```ruby
def []=(k, v)
  if @response.sending? || @response.sent?
    raise ActionDispatch::IllegalStateError, "header already sent"
  end

  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:49
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:54</summary>

##### AbstractController::Rendering#rendered_format

```ruby
def rendered_format
  Mime[:text]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:40</summary>

##### Mime.[]

```ruby
def [](type)
  return type if type.is_a?(Type)
  Type.lookup_by_extension(type)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:55
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:148</summary>

##### Mime::Type.lookup_by_extension

```ruby
def lookup_by_extension(extension)
  EXTENSION_LOOKUP[extension.to_s]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/mime_type.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:75</summary>

##### ActionController::Rendering#_set_rendered_content_type

```ruby
def _set_rendered_content_type(format)
  if format && !response.content_type
    self.content_type = format.to_s
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:247</summary>

##### ActionDispatch::Response#content_type

```ruby
def content_type
  parsed_content_type_header.mime_type
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/rendering.rb:76
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:422</summary>

##### ActionDispatch::Response#parsed_content_type_header

```ruby
def parsed_content_type_header
  parse_content_type(get_header(CONTENT_TYPE))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:248
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:412</summary>

##### ActionDispatch::Response#parse_content_type

```ruby
def parse_content_type(content_type)
  if content_type && match = CONTENT_TYPE_PARSER.match(content_type)
    ContentTypeHeader.new(match[:type], match[:charset])
  else
    NullContentTypeHeader
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:175</summary>

##### ActionController::Metal#response_body=

```ruby
def response_body=(body)
  body = [body] unless body.nil? || body.respond_to?(:each)
  response.reset_body!
  return unless body
  response.body = body
  super
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/abstract_controller/rendering.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:352</summary>

##### ActionDispatch::Response#reset_body!

```ruby
def reset_body!
  @stream = build_buffer(self, [])
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:177
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:452</summary>

##### ActionDispatch::Response#build_buffer

```ruby
def build_buffer(response, body)
  Buffer.new response, body
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:353
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:100</summary>

##### ActionDispatch::Response::Buffer#initialize

```ruby
def initialize(response, buf)
  @response = response
  @buf      = buf
  @closed   = false
  @str_body = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:453
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:312</summary>

##### ActionDispatch::Response#body=

```ruby
def body=(body)
  if body.respond_to?(:to_path)
    @stream = body
  else
    synchronize do
      @stream = build_buffer self, munge_body_object(body)
    end
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:179
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:316
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:456</summary>

##### ActionDispatch::Response#munge_body_object

```ruby
def munge_body_object(body)
  body.respond_to?(:each) ? body : [body]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:317
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:452</summary>

##### ActionDispatch::Response#build_buffer

```ruby
def build_buffer(response, body)
  Buffer.new response, body
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:317
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:100</summary>

##### ActionDispatch::Response::Buffer#initialize

```ruby
def initialize(response, buf)
  @response = response
  @buf      = buf
  @closed   = false
  @str_body = nil
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:453
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:15</summary>

##### ActiveRecord::LogSubscriber.reset_runtime

```ruby
def self.reset_runtime
  rt, self.runtime = runtime, 0
  rt
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:32
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:11</summary>

##### ActiveRecord::LogSubscriber.runtime

```ruby
def self.runtime
  ActiveRecord::RuntimeRegistry.sql_runtime ||= 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:7</summary>

##### ActiveRecord::LogSubscriber.runtime=

```ruby
def self.runtime=(value)
  ActiveRecord::RuntimeRegistry.sql_runtime = value
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime=

```ruby
class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:184</summary>

##### ActionController::Metal#performed?

```ruby
def performed?
  response_body || response.committed?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/basic_implicit_render.rb:6
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:516</summary>

##### ActiveSupport::Callbacks::CallbackSequence#invoke_after

```ruby
def invoke_after(arg)
  @after.each { |a| a.call(arg) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/callbacks.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:40</summary>

##### ActiveRecord::Railties::ControllerRuntime#append_info_to_payload

```ruby
def append_info_to_payload(payload)
  super
  if ActiveRecord::Base.connected?
    payload[:db_runtime] = (db_runtime || 0) + ActiveRecord::LogSubscriber.reset_runtime
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:38
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:92</summary>

##### ActiveRecord::Railties::ControllerRuntime#append_info_to_payload

```ruby
def append_info_to_payload(payload)
  super
  if ActiveRecord::Base.connected?
    payload[:db_runtime] = (db_runtime || 0) + ActiveRecord::LogSubscriber.reset_runtime
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:41
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:122</summary>

##### ActiveRecord::ConnectionHandling.connected?

```ruby
def connected?
  connection_handler.connected?(connection_specification_name)
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:42
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:130</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/class/attribute.rb:106</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
redefine_method(name) { val }
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/core.rb:131
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:96</summary>

##### ActiveRecord::ConnectionHandling.connection_specification_name

```ruby
def connection_specification_name
  if !defined?(@connection_specification_name) || @connection_specification_name.nil?
    return self == Base ? "primary" : superclass.connection_specification_name
  end
  @connection_specification_name
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1019</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#connected?

```ruby
def connected?(spec_name)
  conn = retrieve_connection_pool(spec_name)
  conn && conn.connected?
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_handling.rb:123
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1039</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection_pool

```ruby
def retrieve_connection_pool(spec_name)
  owner_to_pool.fetch(spec_name) do
    # Check if a connection was previously established in an ancestor process,
    # which may have been forked.
    if ancestor_pool = pool_from_any_process_for(spec_name)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection(ancestor_pool.spec.to_hash).tap do |pool|
        pool.schema_cache = ancestor_pool.schema_cache if ancestor_pool.schema_cache
      end
    else
      owner_to_pool[spec_name] = nil
    end
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1020
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1058</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1059
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:168</summary>

##### Concurrent::Map#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1040
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:108</summary>

##### Concurrent::Collection::NonConcurrentMapBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:169
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:422</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionPool#connected?

```ruby
def connected?
  synchronize { @connections.any? }
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:1021
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/connection_adapters/abstract/connection_pool.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:15</summary>

##### ActiveRecord::LogSubscriber.reset_runtime

```ruby
def self.reset_runtime
  rt, self.runtime = runtime, 0
  rt
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:43
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:11</summary>

##### ActiveRecord::LogSubscriber.runtime

```ruby
def self.runtime
  ActiveRecord::RuntimeRegistry.sql_runtime ||= 0
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:12
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:7</summary>

##### ActiveRecord::LogSubscriber.runtime=

```ruby
def self.runtime=(value)
  ActiveRecord::RuntimeRegistry.sql_runtime = value
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:16
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21</summary>

##### ActiveRecord::RuntimeRegistry.sql_runtime=

```ruby
class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/log_subscriber.rb:8
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/runtime_registry.rb:21
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:43</summary>

##### ActiveSupport::Notifications::Instrumenter#finish_with_state

```ruby
def finish_with_state(listeners_state, name, payload)
  @notifier.finish name, @id, payload, listeners_state
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:47</summary>

##### ActiveSupport::Notifications::Fanout#finish

```ruby
def finish(name, id, payload, listeners = listeners_for(name))
  listeners.each { |s| s.finish(name, id, payload) }
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:103</summary>

##### ActiveSupport::Notifications::Fanout::Subscribers::Evented#finish

```ruby
def finish(name, id, payload)
  @delegate.finish name, id, payload
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:48
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:83</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/fanout.rb:104
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:94</summary>

##### ActiveSupport::LogSubscriber#finish

```ruby
def finish(name, id, payload)
  super if logger
rescue => e
  if logger
    logger.error "Could not log #{name.inspect} event. #{e.class}: #{e.message} #{e.backtrace}"
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:84
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:110</summary>

##### ActiveSupport::Subscriber#now

```ruby
def now
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:95
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:106</summary>

##### ActiveSupport::Subscriber#event_stack

```ruby
def event_stack
  SubscriberQueueRegistry.instance.get_queue(@queue_key)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:126</summary>

##### ActiveSupport::SubscriberQueueRegistry#get_queue

```ruby
def get_queue(queue_key)
  @registry[queue_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:107
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:19</summary>

##### ActionController::LogSubscriber#process_action

```ruby
def process_action(event)
  info do
    payload   = event.payload
    additions = ActionController::Base.log_process_action(payload)

    status = payload[:status]
    if status.nil? && payload[:exception].present?
      exception_class_name = payload[:exception].first
      status = ActionDispatch::ExceptionWrapper.status_code_for_exception(exception_class_name)
    end
    message = "Completed #{status} #{Rack::Utils::HTTP_STATUS_CODES[status]} in #{event.duration.round}ms".dup
    message << " (#{additions.join(" | ".freeze)})" unless additions.empty?
    message << "\n\n" if defined?(Rails.env) && Rails.env.development?

    message
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/subscriber.rb:101
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:95</summary>

##### ActiveSupport::LogSubscriber#info

```ruby
def #{level}(progname = nil, &block)
  logger.#{level}(progname, &block) if logger
end
      METHOD
    end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:20
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:72</summary>

##### ActionController::LogSubscriber#logger

```ruby
def logger
  ActionController::Base.logger
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115</summary>

##### ActionController::Base.logger

```ruby
reader, reader_line = "def #{name}; config.#{name}; end", __LINE__
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:73
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:30</summary>

##### ActiveSupport::Configurable::ClassMethods.config

```ruby
def config
  @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)
    superclass.config.inheritable_copy
  else
    # create a new "anonymous" class that will host the compiled reader methods
    Class.new(Configuration).new
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:23</summary>

##### 0x00007f817f491710#logger

```ruby
def #{key}; _get(#{key.inspect}); end
          RUBY
        end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/configurable.rb:115
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:524</summary>

##### Logger#info

```ruby
def info(progname = nil, &block)
  add(INFO, nil, progname, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:96
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:26</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:525
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### ActiveSupport::Logger#add

```ruby
def add(severity, message = nil, progname = nil, &block)
  return true if @logdev.nil? || (severity || UNKNOWN) < level
  super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:48</summary>

##### ActiveRecord::Railties::ControllerRuntime::ClassMethods.log_process_action

```ruby
def log_process_action(payload)
  messages, db_runtime = super, payload[:db_runtime]
  messages << ("ActiveRecord: %.1fms" % db_runtime.to_f) if db_runtime
  messages
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:100</summary>

##### ActiveRecord::Railties::ControllerRuntime::ClassMethods.log_process_action

```ruby
def log_process_action(payload)
  messages, db_runtime = super, payload[:db_runtime]
  messages << ("ActiveRecord: %.1fms" % db_runtime.to_f) if db_runtime
  messages
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:49
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/numeric/conversions.rb:104</summary>

##### ActiveSupport::NumericWithFormat#to_s

```ruby
def to_s(format = nil, options = nil)
  case format
  when nil
    super()
  when Integer, String
    super(format)
  when :phone
    ActiveSupport::NumberHelper.number_to_phone(self, options || {})
  when :currency
    ActiveSupport::NumberHelper.number_to_currency(self, options || {})
  when :percentage
    ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
  when :delimited
    ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
  when :rounded
    ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
  when :human
    ActiveSupport::NumberHelper.number_to_human(self, options || {})
  when :human_size
    ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
  when Symbol
    super()
  else
    super(format)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:80</summary>

##### ActiveSupport::Notifications::Event#duration

```ruby
def duration
  @duration ||= 1000.0 * (self.end - time)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/numeric/conversions.rb:104</summary>

##### ActiveSupport::NumericWithFormat#to_s

```ruby
def to_s(format = nil, options = nil)
  case format
  when nil
    super()
  when Integer, String
    super(format)
  when :phone
    ActiveSupport::NumberHelper.number_to_phone(self, options || {})
  when :currency
    ActiveSupport::NumberHelper.number_to_currency(self, options || {})
  when :percentage
    ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
  when :delimited
    ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
  when :rounded
    ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
  when :human
    ActiveSupport::NumberHelper.number_to_human(self, options || {})
  when :human_size
    ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
  when Symbol
    super()
  else
    super(format)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails.rb:72</summary>

##### Rails.env

```ruby
def env
  @_env ||= ActiveSupport::StringInquirer.new(ENV["RAILS_ENV"].presence || ENV["RACK_ENV"].presence || "development")
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/string_inquirer.rb:26</summary>

##### ActiveSupport::StringInquirer#method_missing

```ruby
def method_missing(method_name, *arguments)
  if method_name[-1] == "?"
    self == method_name[0..-2]
  else
    super
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:31
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::Logger::SimpleFormatter#call

```ruby
def call(severity, timestamp, progname, msg)
  "#{String === msg ? msg : msg.inspect}\n"
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:87</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:28
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:29</summary>

##### ActiveSupport::LoggerThreadSafeLevel#level

```ruby
def level
  local_level || super
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:88
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:17</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_level

```ruby
def local_level
  @local_levels[local_log_id]
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:13</summary>

##### ActiveSupport::LoggerThreadSafeLevel#local_log_id

```ruby
def local_log_id
  Thread.current.__id__
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:132</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger_thread_safe_level.rb:18
```
</details>
<details open>
<summary>vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/collection/map/non_concurrent_map_backend.rb:19</summary>

##### Concurrent::Map#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
    # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
    # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
    # would be returned)
    # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end
# called from vendor/bundle/gems/concurrent-ruby-1.1.5/lib/concurrent/map.rb:133
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:455</summary>

##### #<Module:0x00007f817f4bb448>#add

```ruby
define_method(:add) do |*args, &block|
  logger.add(*args, &block)
  super(*args, &block)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:89
```
</details>
<details open>
<summary>vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:48</summary>

##### ActiveRecord::Railties::ControllerRuntime::ClassMethods.log_process_action

```ruby
def log_process_action(payload)
  messages, db_runtime = super, payload[:db_runtime]
  messages << ("ActiveRecord: %.1fms" % db_runtime.to_f) if db_runtime
  messages
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:22
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal/instrumentation.rb:100</summary>

##### ActiveRecord::Railties::ControllerRuntime::ClassMethods.log_process_action

```ruby
def log_process_action(payload)
  messages, db_runtime = super, payload[:db_runtime]
  messages << ("ActiveRecord: %.1fms" % db_runtime.to_f) if db_runtime
  messages
end
# called from vendor/bundle/gems/activerecord-5.2.3/lib/active_record/railties/controller_runtime.rb:49
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/numeric/conversions.rb:104</summary>

##### ActiveSupport::NumericWithFormat#to_s

```ruby
def to_s(format = nil, options = nil)
  case format
  when nil
    super()
  when Integer, String
    super(format)
  when :phone
    ActiveSupport::NumberHelper.number_to_phone(self, options || {})
  when :currency
    ActiveSupport::NumberHelper.number_to_currency(self, options || {})
  when :percentage
    ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
  when :delimited
    ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
  when :rounded
    ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
  when :human
    ActiveSupport::NumberHelper.number_to_human(self, options || {})
  when :human_size
    ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
  when Symbol
    super()
  else
    super(format)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/notifications/instrumenter.rb:80</summary>

##### ActiveSupport::Notifications::Event#duration

```ruby
def duration
  @duration ||= 1000.0 * (self.end - time)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/core_ext/numeric/conversions.rb:104</summary>

##### ActiveSupport::NumericWithFormat#to_s

```ruby
def to_s(format = nil, options = nil)
  case format
  when nil
    super()
  when Integer, String
    super(format)
  when :phone
    ActiveSupport::NumberHelper.number_to_phone(self, options || {})
  when :currency
    ActiveSupport::NumberHelper.number_to_currency(self, options || {})
  when :percentage
    ActiveSupport::NumberHelper.number_to_percentage(self, options || {})
  when :delimited
    ActiveSupport::NumberHelper.number_to_delimited(self, options || {})
  when :rounded
    ActiveSupport::NumberHelper.number_to_rounded(self, options || {})
  when :human
    ActiveSupport::NumberHelper.number_to_human(self, options || {})
  when :human_size
    ActiveSupport::NumberHelper.number_to_human_size(self, options || {})
  when Symbol
    super()
  else
    super(format)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/railties-5.2.3/lib/rails.rb:72</summary>

##### Rails.env

```ruby
def env
  @_env ||= ActiveSupport::StringInquirer.new(ENV["RAILS_ENV"].presence || ENV["RACK_ENV"].presence || "development")
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:31
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/string_inquirer.rb:26</summary>

##### ActiveSupport::StringInquirer#method_missing

```ruby
def method_missing(method_name, *arguments)
  if method_name[-1] == "?"
    self == method_name[0..-2]
  else
    super
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/log_subscriber.rb:31
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:577</summary>

##### Logger#format_severity

```ruby
def format_severity(severity)
  SEV_LABEL[severity] || 'ANY'
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:581</summary>

##### Logger#format_message

```ruby
def format_message(severity, datetime, progname, msg)
  (@formatter || @default_formatter).call(severity, datetime, progname, msg)
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:472
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:22</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:582
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:53</summary>

##### ActiveSupport::TaggedLogging::Formatter#tags_text

```ruby
def tags_text
  tags = current_tags
  if tags.any?
    tags.collect { |tag| "[#{tag}] " }.join
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/logger.rb:103</summary>

##### ActiveSupport::TaggedLogging::Formatter#call

```ruby
def call(severity, timestamp, progname, msg)
  super(severity, timestamp, progname, "#{tags_text}#{msg}")
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:23
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:684</summary>

##### Logger::LogDevice#write

```ruby
def write(message)
  begin
    synchronize do
      if @shift_age and @dev.respond_to?(:stat)
        begin
          check_shift_log
        rescue
          warn("log shifting failed. #{$!}")
        end
      end
      begin
        @dev.write(message)
      rescue
        warn("log writing failed. #{$!}")
      end
    end
  rescue Exception => ignored
    warn("log writing failed. #{ignored}")
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:471
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/logger.rb:686
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:417</summary>

##### ActionDispatch::Request#commit_flash

```ruby
def commit_flash
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:192
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:205</summary>

##### ActionController::Metal#to_a

```ruby
def to_a #:nodoc:
  response.to_a
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:193
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:384</summary>

##### ActionDispatch::Response#to_a

```ruby
def to_a
  commit!
  rack_response @status, @header.to_hash
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_controller/metal.rb:206
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:196</summary>

##### ActionDispatch::Response#commit!

```ruby
def commit!
  synchronize do
    before_committed
    @committed = true
    @cv.broadcast
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:385
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:197
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:432</summary>

##### ActionDispatch::Response#before_committed

```ruby
def before_committed
  return if committed?
  assign_default_content_type_and_charset!
  merge_and_normalize_cache_control!(@cache_control)
  handle_conditional_get!
  handle_no_content!
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:198
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220</summary>

##### ActionDispatch::Response#committed?

```ruby
def committed?; synchronize { @committed }; end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:433
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:460</summary>

##### ActionDispatch::Response#assign_default_content_type_and_charset!

```ruby
def assign_default_content_type_and_charset!
  return if content_type

  ct = parsed_content_type_header
  set_content_type(ct.mime_type || Mime[:html].to_s,
                   ct.charset || self.class.default_charset)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:434
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:247</summary>

##### ActionDispatch::Response#content_type

```ruby
def content_type
  parsed_content_type_header.mime_type
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:461
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:422</summary>

##### ActionDispatch::Response#parsed_content_type_header

```ruby
def parsed_content_type_header
  parse_content_type(get_header(CONTENT_TYPE))
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:248
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:412</summary>

##### ActionDispatch::Response#parse_content_type

```ruby
def parse_content_type(content_type)
  if content_type && match = CONTENT_TYPE_PARSER.match(content_type)
    ContentTypeHeader.new(match[:type], match[:charset])
  else
    NullContentTypeHeader
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:423
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:185</summary>

##### ActionDispatch::Http::Cache::Response#merge_and_normalize_cache_control!

```ruby
def merge_and_normalize_cache_control!(cache_control)
  control = {}
  cc_headers = cache_control_headers
  if extras = cc_headers.delete(:extras)
    cache_control[:extras] ||= []
    cache_control[:extras] += extras
    cache_control[:extras].uniq!
  end

  control.merge! cc_headers
  control.merge! cache_control

  if control.empty?
    # Let middleware handle default behavior
  elsif control[:no_cache]
    options = []
    options << PUBLIC if control[:public]
    options << NO_CACHE
    options.concat(control[:extras]) if control[:extras]

    self._cache_control = options.join(", ")
  else
    extras  = control[:extras]
    max_age = control[:max_age]

    options = []
    options << "max-age=#{max_age.to_i}" if max_age
    options << (control[:public] ? PUBLIC : PRIVATE)
    options << MUST_REVALIDATE if control[:must_revalidate]
    options.concat(extras) if extras

    self._cache_control = options.join(", ")
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:435
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:147</summary>

##### ActionDispatch::Http::Cache::Response#cache_control_headers

```ruby
def cache_control_headers
  cache_control = {}

  cache_control_segments.each do |segment|
    directive, argument = segment.split("=", 2)

    if SPECIAL_KEYS.include? directive
      key = directive.tr("-", "_")
      cache_control[key.to_sym] = argument || true
    else
      cache_control[:extras] ||= []
      cache_control[:extras] << segment
    end
  end

  cache_control
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:187
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:139</summary>

##### ActionDispatch::Http::Cache::Response#cache_control_segments

```ruby
def cache_control_segments
  if cache_control = _cache_control
    cache_control.delete(" ").split(",")
  else
    []
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:150
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:199</summary>

##### ActionDispatch::Http::Cache::Response#cache_control

```ruby
attr_reader :cache_control
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:140
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:175</summary>

##### ActionDispatch::Http::Cache::Response#handle_conditional_get!

```ruby
def handle_conditional_get!
  # Normally default cache control setting is handled by ETag
  # middleware. But, if an etag is already set, the middleware
  # defaults to `no-cache` unless a default `Cache-Control` value is
  # previously set. So, set a default one here.
  if (etag? || last_modified?) && !self._cache_control
    self._cache_control = DEFAULT_CACHE_CONTROL
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:436
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:113</summary>

##### ActionDispatch::Http::Cache::Response#etag?

```ruby
def etag?; etag; end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:180
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:207</summary>

##### Rack::Response::Helpers#etag

```ruby
def etag
  get_header ETAG
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:113
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182</summary>

##### ActionDispatch::Response#get_header

```ruby
def get_header(key);    headers[key];       end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/response.rb:208
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#[]

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:182
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:60</summary>

##### ActionDispatch::Http::Cache::Response#last_modified?

```ruby
def last_modified?
  has_header? LAST_MODIFIED
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:180
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:181</summary>

##### ActionDispatch::Response#has_header?

```ruby
def has_header?(key);   headers.key? key;   end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/cache.rb:61
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:347</summary>

##### 0x00007f817f2ce220#key?

```ruby
lambda do |*args, &block|
  target = self.__getobj__
  target.__send__(mid, *args, &block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:181
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:348
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:504</summary>

##### ActionDispatch::Response#handle_no_content!

```ruby
def handle_no_content!
  if NO_CONTENT_CODES.include?(@status)
    @header.delete CONTENT_TYPE
    @header.delete "Content-Length"
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:437
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:149</summary>

##### MonitorMixin::ConditionVariable#broadcast

```ruby
def broadcast
  @monitor.__send__(:mon_check_owner)
  @cond.broadcast
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:150
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:56</summary>

##### ActionDispatch::Response::Header#to_hash

```ruby
def to_hash
  __getobj__.dup
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:386
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:57
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:511</summary>

##### ActionDispatch::Response#rack_response

```ruby
def rack_response(status, header)
  if NO_CONTENT_CODES.include?(status)
    [status, header, []]
  else
    [status, header, RackBody.new(self)]
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:386
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:469</summary>

##### ActionDispatch::Response::RackBody#initialize

```ruby
def initialize(response)
  @response = response
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:515
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:49</summary>

##### Rack::ETag#etag_status?

```ruby
def etag_status?(status)
  status == 200 || status == 201
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:53</summary>

##### Rack::ETag#etag_body?

```ruby
def etag_body?(body)
  !body.respond_to?(:to_path)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:487</summary>

##### ActionDispatch::Response::RackBody#respond_to?

```ruby
def respond_to?(method, include_private = false)
  if method.to_s == "to_path"
    @response.stream.respond_to?(method)
  else
    super
  end
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:54
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:57</summary>

##### Rack::ETag#skip_caching?

```ruby
def skip_caching?(headers)
  (headers[CACHE_CONTROL] && headers[CACHE_CONTROL].include?('no-cache')) ||
    headers.key?(ETAG_STRING) || headers.key?('Last-Modified')
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:62</summary>

##### Rack::ETag#digest_body

```ruby
def digest_body(body)
  parts = []
  digest = nil

  body.each do |part|
    parts << part
    (digest ||= Digest::SHA256.new) << part unless part.empty?
  end

  [digest && digest.hexdigest.byteslice(0, 32), parts]
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:29
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:473</summary>

##### ActionDispatch::Response::RackBody#each

```ruby
def each(*args, &block)
  @response.each(*args, &block)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:66
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:74</summary>

##### ActionDispatch::Response#each

```ruby
def each(&block)
  sending!
  x = @stream.each(&block)
  sent!
  x
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:474
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:204</summary>

##### ActionDispatch::Response#sending!

```ruby
def sending!
  synchronize do
    before_sending
    @sending = true
    @cv.broadcast
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:75
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:205
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:440</summary>

##### ActionDispatch::Response#before_sending

```ruby
def before_sending
  # Normally we've already committed by now, but it's possible
  # (e.g., if the controller action tries to read back its own
  # response) to get here before that. In that case, we must force
  # an "early" commit: we're about to freeze the headers, so this is
  # our last chance.
  commit! unless committed?

  headers.freeze
  request.commit_cookie_jar! unless committed?
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:206
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220</summary>

##### ActionDispatch::Response#committed?

```ruby
def committed?; synchronize { @committed }; end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:446
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:238</summary>

##### Delegator#freeze

```ruby
define_method method do
  __getobj__.send(method)
  super()
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:448
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:392</summary>

##### 0x00007f817f2ce220#__getobj__

```ruby
def __getobj__ # :nodoc:
  unless defined?(@delegate_dc_obj)
    return yield if block_given?
    __raise__ ::ArgumentError, "not delegated"
  end
  @delegate_dc_obj
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/delegate.rb:239
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220</summary>

##### ActionDispatch::Response#committed?

```ruby
def committed?; synchronize { @committed }; end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:449
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:220
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:149</summary>

##### MonitorMixin::ConditionVariable#broadcast

```ruby
def broadcast
  @monitor.__send__(:mon_check_owner)
  @cond.broadcast
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:208
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:150
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:123</summary>

##### ActionDispatch::Response::Buffer#each

```ruby
def each(&block)
  if @str_body
    return enum_for(:each) unless block_given?

    yield @str_body
  else
    each_chunk(&block)
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:76
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:147</summary>

##### ActionDispatch::Response::Buffer#each_chunk

```ruby
def each_chunk(&block)
  @buf.each(&block)
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:129
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:212</summary>

##### ActionDispatch::Response#sent!

```ruby
def sent!
  synchronize do
    @sent = true
    @cv.broadcast
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:77
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:227</summary>

##### MonitorMixin#mon_synchronize

```ruby
def mon_synchronize
  mon_enter
  begin
    yield
  ensure
    mon_exit
  end
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:213
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:187</summary>

##### MonitorMixin#mon_enter

```ruby
def mon_enter
  if @mon_owner != Thread.current
    @mon_mutex.lock
    @mon_owner = Thread.current
    @mon_count = 0
  end
  @mon_count += 1
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:228
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:149</summary>

##### MonitorMixin::ConditionVariable#broadcast

```ruby
def broadcast
  @monitor.__send__(:mon_check_owner)
  @cond.broadcast
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/response.rb:215
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:150
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:199</summary>

##### MonitorMixin#mon_exit

```ruby
def mon_exit
  mon_check_owner
  @mon_count -=1
  if @mon_count == 0
    @mon_owner = nil
    @mon_mutex.unlock
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:232
```
</details>
<details open>
<summary>/Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:267</summary>

##### MonitorMixin#mon_check_owner

```ruby
def mon_check_owner
  if @mon_owner != Thread.current
    raise ThreadError, "current thread not owner"
  end
end
# called from /Users/yhirano/.rbenv/versions/2.6.3/lib/ruby/2.6.0/monitor.rb:200
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:3</summary>

##### Rack::BodyProxy#initialize

```ruby
def initialize(body, &block)
  @body = body
  @block = block
  @closed = false
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/etag.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:436</summary>

##### Rack::Utils::HeaderHash.new

```ruby
def self.new(hash={})
  HeaderHash === hash ? hash : super(hash)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/conditional_get.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:440</summary>

##### Rack::Utils::HeaderHash#initialize

```ruby
def initialize(hash={})
  super()
  @names = {}
  hash.each { |k, v| self[k] = v }
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:437
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:468</summary>

##### Rack::Utils::HeaderHash#[]=

```ruby
def []=(k, v)
  canonical = k.downcase.freeze
  delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
  @names[canonical] = k
  super k, v
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:443
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:468</summary>

##### Rack::Utils::HeaderHash#[]=

```ruby
def []=(k, v)
  canonical = k.downcase.freeze
  delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
  @names[canonical] = k
  super k, v
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:443
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:468</summary>

##### Rack::Utils::HeaderHash#[]=

```ruby
def []=(k, v)
  canonical = k.downcase.freeze
  delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
  @names[canonical] = k
  super k, v
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:443
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/conditional_get.rb:44</summary>

##### Rack::ConditionalGet#fresh?

```ruby
def fresh?(env, headers)
  modified_since = env['HTTP_IF_MODIFIED_SINCE']
  none_match     = env['HTTP_IF_NONE_MATCH']

  return false unless modified_since || none_match

  success = true
  success &&= modified_since?(to_rfc2822(modified_since), headers) if modified_since
  success &&= etag_matches?(none_match, headers) if none_match
  success
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/conditional_get.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:3</summary>

##### Rack::BodyProxy#initialize

```ruby
def initialize(body, &block)
  @body = body
  @block = block
  @closed = false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:464</summary>

##### Rack::Utils::HeaderHash#[]

```ruby
def [](k)
  super(k) || super(@names[k.downcase])
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:63
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:3</summary>

##### Rack::BodyProxy#initialize

```ruby
def initialize(body, &block)
  @body = body
  @block = block
  @closed = false
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:39
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:70</summary>

##### ActiveSupport::LogSubscriber.flush_all!

```ruby
def flush_all!
  logger.flush if logger.respond_to?(:flush)
end
# called from vendor/bundle/gems/railties-5.2.3/lib/rails/rack/logger.rb:45
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:57</summary>

##### ActiveSupport::LogSubscriber.logger

```ruby
def logger
  @logger ||= if defined?(Rails) && Rails.respond_to?(:logger)
    Rails.logger
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:57</summary>

##### ActiveSupport::LogSubscriber.logger

```ruby
def logger
  @logger ||= if defined?(Rails) && Rails.respond_to?(:logger)
    Rails.logger
  end
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:74</summary>

##### ActiveSupport::TaggedLogging#flush

```ruby
def flush
  clear_tags!
  super if defined?(super)
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/log_subscriber.rb:71
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:68</summary>

##### ActiveSupport::TaggedLogging#clear_tags!

```ruby
delegate :push_tags, :pop_tags, :clear_tags!, to: :formatter
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:75
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:43</summary>

##### ActiveSupport::TaggedLogging::Formatter#clear_tags!

```ruby
def clear_tags!
  current_tags.clear
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:68
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:44
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:39</summary>

##### ActiveSupport::TaggedLogging::Formatter#pop_tags

```ruby
def pop_tags(size = 1)
  current_tags.pop size
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:47</summary>

##### ActiveSupport::TaggedLogging::Formatter#current_tags

```ruby
def current_tags
  # We use our object ID here to avoid conflicting with other instances
  thread_key = @thread_key ||= "activesupport_tagged_logging_tags:#{object_id}".freeze
  Thread.current[thread_key] ||= []
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/tagged_logging.rb:40
```
</details>
<details open>
<summary>vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:294</summary>

##### ActionDispatch::Request#request_id

```ruby
def request_id
  get_header ACTION_DISPATCH_REQUEST_ID
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/request.rb:52</summary>

##### Rack::Request::Env#get_header

```ruby
def get_header(name)
  @env[name]
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/http/request.rb:295
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:468</summary>

##### Rack::Utils::HeaderHash#[]=

```ruby
def []=(k, v)
  canonical = k.downcase.freeze
  delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
  @names[canonical] = k
  super k, v
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/request_id.rb:27
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:81</summary>

##### Rack::Utils.clock_time

```ruby
def clock_time
  Process.clock_gettime(Process::CLOCK_MONOTONIC)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:23
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:481</summary>

##### Rack::Utils::HeaderHash#include?

```ruby
def include?(k)
  super || @names.include?(k.downcase)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:25
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/utils.rb:468</summary>

##### Rack::Utils::HeaderHash#[]=

```ruby
def []=(k, v)
  canonical = k.downcase.freeze
  delete k if @names[canonical] && @names[canonical] != k # .delete is expensive, don't invoke it unless necessary
  @names[canonical] = k
  super k, v
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/runtime.rb:26
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:3</summary>

##### Rack::BodyProxy#initialize

```ruby
def initialize(body, &block)
  @body = body
  @block = block
  @closed = false
end
# called from vendor/bundle/gems/activesupport-5.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:30
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:3</summary>

##### Rack::BodyProxy#initialize

```ruby
def initialize(body, &block)
  @body = body
  @block = block
  @closed = false
end
# called from vendor/bundle/gems/actionpack-5.2.3/lib/action_dispatch/middleware/executor.rb:15
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:9</summary>

##### Rack::BodyProxy#respond_to?

```ruby
def respond_to?(method_name, include_all=false)
  case method_name
  when :to_ary, 'to_ary'
    return false
  end
  super or @body.respond_to?(method_name, include_all)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/sendfile.rb:112
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:9</summary>

##### Rack::BodyProxy#respond_to?

```ruby
def respond_to?(method_name, include_all=false)
  case method_name
  when :to_ary, 'to_ary'
    return false
  end
  super or @body.respond_to?(method_name, include_all)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:9</summary>

##### Rack::BodyProxy#respond_to?

```ruby
def respond_to?(method_name, include_all=false)
  case method_name
  when :to_ary, 'to_ary'
    return false
  end
  super or @body.respond_to?(method_name, include_all)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:9</summary>

##### Rack::BodyProxy#respond_to?

```ruby
def respond_to?(method_name, include_all=false)
  case method_name
  when :to_ary, 'to_ary'
    return false
  end
  super or @body.respond_to?(method_name, include_all)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:14
```
</details>
<details open>
<summary>vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:9</summary>

##### Rack::BodyProxy#respond_to?

```ruby
def respond_to?(method_name, include_all=false)
  case method_name
  when :to_ary, 'to_ary'
    return false
  end
  super or @body.respond_to?(method_name, include_all)
end
# called from vendor/bundle/gems/rack-2.0.7/lib/rack/body_proxy.rb:14
```
</details>
